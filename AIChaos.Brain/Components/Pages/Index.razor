@page "/"
@rendermode InteractiveServer
@inject CommandQueueService CommandQueue
@inject AiCodeGeneratorService CodeGenerator
@inject ImageModerationService ModerationService
@inject SettingsService SettingsService
@inject IJSRuntime JS

<PageTitle>AI Chaos - Viewer Control</PageTitle>

<Header Title="üéÆ AI CHAOS VIEWER" />

<NavMenu />

<div class="card">
    <h2>Send Chaos Command</h2>
    <div class="form-group">
        <textarea @bind="promptInput" placeholder="@GetPlaceholder()" disabled="@(currentAccount == null)"></textarea>
    </div>

    <div class="form-group" style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
            <input type="checkbox" @bind="interactiveMode" style="width: 18px; height: 18px;">
            <span>üîÑ Interactive Mode</span>
            <span style="color: var(--text-dim); font-size: 12px;">(AI iterates with game)</span>
        </label>
    </div>

    <button @onclick="SubmitCommand" disabled="@(currentAccount == null || isSubmitting)">
        @if (isSubmitting)
        {
            <text>‚è≥ SENDING...</text>
        }
        else if (currentAccount == null)
        {
            <text>üîí LOGIN TO PLAY</text>
        }
        else
        {
            <text>‚ö° SEND CHAOS ($0.10)</text>
        }
    </button>
    
    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div style="margin-top: 15px;">
            <div class="alert alert-@statusType">@statusMessage</div>
        </div>
    }
</div>

<div class="card">
    <h2>üìã Your Recent Commands</h2>
    <div id="recentCommands">
        @if (recentCommands == null || !recentCommands.Any())
        {
            <div class="empty-state">@(currentAccount == null ? "Sign in to see your history..." : "No commands yet.")</div>
        }
        else
        {
            @foreach (var cmd in recentCommands)
            {
                <div class="history-item">
                    <div style="flex: 1;">
                        <div class="history-time">@cmd.Timestamp.ToLocalTime().ToString("HH:mm:ss")</div>
                        <div class="history-prompt">@cmd.UserPrompt</div>
                        <div class="history-status status-@GetStatusClass(cmd.Status)">@GetStatusText(cmd.Status)</div>
                    </div>
                    <div class="history-actions">
                        <button @onclick="() => UndoCommand(cmd.Id)" class="btn-warning btn-small">‚Ü© Undo</button>
                    </div>
                </div>
            }
        }
    </div>
</div>

@* Login/Register Modal *@

<style>
    .history-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        margin-bottom: 10px;
    }

    .history-time {
        color: var(--text-dim);
        font-size: 12px;
    }

    .history-prompt {
        color: var(--text);
        margin: 5px 0;
    }

    .history-status {
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        display: inline-block;
    }

    .status-pending { background: #888; }
    .status-queued { background: #f0ad4e; }
    .status-executed { background: #5cb85c; }
    .status-undone { background: #5bc0de; }
    .status-failed { background: #d9534f; }
</style>

@code {
    [CascadingParameter]
    private Account? currentAccount { get; set; }
    
    private string promptInput = "";
    private bool interactiveMode = false;
    private List<CommandEntry>? recentCommands;
    private string statusMessage = "";
    private string statusType = "info";
    private bool isSubmitting = false;

    protected override async Task OnParametersSetAsync()
    {
        if (currentAccount != null)
        {
            await LoadHistory();
        }
    }

    private async Task DoLogin()
    {
        loginError = "";
        
        if (string.IsNullOrWhiteSpace(loginUsername) || string.IsNullOrWhiteSpace(loginPassword))
        {
            loginError = "Please enter username and password";
            return;
        }
        
        try
        {
            var (success, error, account, newSessionToken) = AccountService.Login(loginUsername, loginPassword);
            
            if (success && account != null && newSessionToken != null)
            {
                sessionToken = newSessionToken;
                currentAccount = account;
                await JS.InvokeVoidAsync("localStorage.setItem", "aichaos_session", sessionToken);
                showLoginModal = false;
                await LoadHistory();
            }
            else
            {
                loginError = error ?? "Login failed";
            }
        }
        catch (Exception ex)
        {
            loginError = "Error during login";
            Console.WriteLine($"Login failed: {ex.Message}");
        }
    }

    private async Task DoRegister()
    {
        registerError = "";
        
        if (string.IsNullOrWhiteSpace(registerUsername) || string.IsNullOrWhiteSpace(registerPassword))
        {
            registerError = "Please fill in all required fields";
            return;
        }
        
        try
        {
            var displayName = string.IsNullOrWhiteSpace(registerDisplayName) ? null : registerDisplayName;
            var (success, error, account) = AccountService.CreateAccount(registerUsername, registerPassword, displayName);
            
            if (success && account != null)
            {
                // Log them in after registration
                var (loginSuccess, loginError, loginAccount, newSessionToken) = AccountService.Login(registerUsername, registerPassword);
                
                if (loginSuccess && loginAccount != null && newSessionToken != null)
                {
                    sessionToken = newSessionToken;
                    currentAccount = loginAccount;
                    await JS.InvokeVoidAsync("localStorage.setItem", "aichaos_session", sessionToken);
                    showLoginModal = false;
                    await LoadHistory();
                    ShowStatus("Account created! Link your YouTube to receive Super Chat credits.", "success");
                }
                else
                {
                    registerError = "Account created but login failed. Please log in manually.";
                }
            }
            else
            {
                registerError = error ?? "Registration failed";
            }
        }
        catch (Exception ex)
        {
            registerError = "Error during registration";
            Console.WriteLine($"Registration failed: {ex.Message}");
        }
    }

    private async Task Logout()
    {
        if (!string.IsNullOrEmpty(sessionToken))
        {
            try
            {
                AccountService.Logout(sessionToken);
            }
            catch { }
        }
        
        currentAccount = null;
        sessionToken = null;
        recentCommands = null;
        await JS.InvokeVoidAsync("localStorage.removeItem", "aichaos_session");
        StateHasChanged();
    }

    private async Task SubmitCommand()
    {
        if (currentAccount == null || string.IsNullOrWhiteSpace(promptInput) || isSubmitting)
            return;
        
        isSubmitting = true;
        StateHasChanged();
        
        try
        {
            // Check rate limit
            var (allowed, waitSeconds) = AccountService.CheckRateLimit(currentAccount.Id);
            if (!allowed)
            {
                ShowStatus($"Please wait {waitSeconds:F0} seconds before submitting another command.", "error");
                return;
            }

            // Check credits
            if (currentAccount.CreditBalance < Constants.CommandCost)
            {
                ShowStatus($"Insufficient credits. You have ${currentAccount.CreditBalance:F2}, but need ${Constants.CommandCost:F2}", "error");
                return;
            }

            var isPrivateDiscordMode = SettingsService.Settings.Safety.PrivateDiscordMode;

            // Check for images in the prompt - queue for moderation if found (skip if Private Discord Mode)
            if (!isPrivateDiscordMode && ModerationService.NeedsModeration(promptInput))
            {
                var imageUrls = ModerationService.ExtractImageUrls(promptInput);
                foreach (var url in imageUrls)
                {
                    ModerationService.AddPendingImage(
                        url,
                        promptInput,
                        "web",
                        currentAccount.DisplayName,
                        currentAccount.Id);
                }

                promptInput = "";
                ShowStatus($"Your prompt contains {imageUrls.Count} image(s) that require moderator approval before processing.", "info");
                return;
            }

            // Generate code
            var (executionCode, undoCode) = await CodeGenerator.GenerateCodeAsync(promptInput);

            // Deduct credits
            if (!AccountService.DeductCredits(currentAccount.Id, Constants.CommandCost))
            {
                ShowStatus("Failed to deduct credits", "error");
                return;
            }

            // Add command to queue
            var command = CommandQueue.AddCommand(
                userPrompt: promptInput,
                executionCode: executionCode,
                undoCode: undoCode,
                source: "web",
                author: currentAccount.DisplayName,
                imageContext: null,
                userId: currentAccount.Id,
                aiResponse: null
            );

            // Update balance in UI
            var updatedAccount = AccountService.GetAccountBySession(sessionToken!);
            if (updatedAccount != null)
            {
                currentAccount.CreditBalance = updatedAccount.CreditBalance;
            }

            promptInput = "";
            await LoadHistory();
            ShowStatus("Command sent successfully!", "success");
        }
        catch (Exception ex)
        {
            ShowStatus("Error submitting command", "error");
            Console.WriteLine($"Submit failed: {ex.Message}");
        }
        finally
        {
            isSubmitting = false;
            StateHasChanged();
        }
    }

    private Task LoadHistory()
    {
        if (currentAccount == null)
            return Task.CompletedTask;
        
        try
        {
            var history = CommandQueue.GetHistoryForUser(currentAccount.Id);
            recentCommands = history.TakeLast(10).Reverse().ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load history failed: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private Task UndoCommand(int commandId)
    {
        try
        {
            var success = CommandQueue.UndoCommand(commandId);
            ShowStatus(success ? "Undo queued" : "Failed to undo command", success ? "success" : "error");
        }
        catch (Exception ex)
        {
            ShowStatus("Error undoing command", "error");
            Console.WriteLine($"Undo failed: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private void ShowStatus(string message, string type)
    {
        statusMessage = message;
        statusType = type;
        StateHasChanged();
        _ = Task.Delay(3000).ContinueWith(async _ => 
        { 
            await InvokeAsync(() =>
            {
                statusMessage = ""; 
                StateHasChanged();
            });
        });
    }

    private string GetPlaceholder() => currentAccount == null ? "Login to send commands..." : "Ex: Make everyone tiny, Spawn 10 headcrabs...";
    
    private void GenerateLinkCode()
    {
        try
        {
            if (currentAccount == null)
            {
                linkYouTubeError = "You must be logged in to link YouTube";
                return;
            }
            
            if (!string.IsNullOrEmpty(currentAccount.LinkedYouTubeChannelId))
            {
                linkYouTubeError = "YouTube channel already linked";
                return;
            }
            
            linkCode = AccountService.GenerateYouTubeLinkCode(currentAccount.Id);
            linkYouTubeError = "";
            linkYouTubeSuccess = "";
        }
        catch (Exception ex)
        {
            linkYouTubeError = "Error generating link code";
            Console.WriteLine($"Generate link code failed: {ex.Message}");
        }
    }
    
    private void CloseYouTubeLinkModal()
    {
        showLinkYouTubeModal = false;
        linkCode = "";
        linkYouTubeError = "";
        linkYouTubeSuccess = "";
        youtubeLinkMethodChosen = false;
        showOAuthMethod = false;
        showCodeMethod = false;
    }
    
    private void ShowOAuthLinkMethod()
    {
        youtubeLinkMethodChosen = true;
        showOAuthMethod = true;
        showCodeMethod = false;
        // TODO: Check if Google OAuth is configured in settings
        googleOAuthConfigured = false; // For now, not configured
    }
    
    private void ShowCodeLinkMethod()
    {
        youtubeLinkMethodChosen = true;
        showOAuthMethod = false;
        showCodeMethod = true;
    }
    
    private string GetStatusClass(CommandStatus status) => status switch
    {
        CommandStatus.Executed => "executed",
        CommandStatus.Failed => "failed",
        CommandStatus.Queued => "queued",
        CommandStatus.Undone => "undone",
        _ => "pending"
    };
    
    private string GetStatusText(CommandStatus status) => status.ToString();

    private async Task HandleLoginKeypress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
            await DoLogin();
    }
}
