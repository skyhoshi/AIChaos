@using AIChaos.Brain.Models
@using AIChaos.Brain.Services
@implements IDisposable

@inject ImageModerationService ModerationService
@inject RefundService RefundService
@inject CommandQueueService CommandQueue
@inject SettingsService SettingsService
@inject YouTubeService YouTubeService
@inject NavigationManager Navigation
@inject HttpClient Http
@inject IJSRuntime JS

<!-- Global Status Message -->
@if (!string.IsNullOrEmpty(globalMessage))
{
    <div class="alert alert-@globalMessageType" style="margin-bottom: 20px;">@globalMessage</div>
}

<div class="stream-control-grid">
    @if (CurrentAccount?.Role == UserRole.Admin)
    {
        <!-- Manual Blast Controls -->
        <div class="card control-panel">
            <h2>üí• Queue Control</h2>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                <input type="number" @bind="blastCount" min="1" max="10" 
                       style="width: 80px; padding: 10px; text-align: center; background: rgba(255,255,255,0.1); border: 1px solid var(--border); border-radius: 5px; color: var(--text);" 
                       title="Number of commands to blast" />
                <button @onclick="ManualBlast" class="btn-warning" style="flex: 1;">
                    üí• BLAST QUEUE
                </button>
            </div>
            
            <!-- Queue Status -->
            <div class="queue-stats">
                <div class="stat-item">
                    <span class="stat-label">Active Slots:</span>
                    <span class="stat-value">@activeSlots / @totalSlots</span>
                </div>
            </div>
            
            <button @onclick="LoadQueueStatus" class="btn-secondary" style="width: 100%; margin-top: 10px;">
                üîÑ Refresh Status
            </button>
            
            @if (!string.IsNullOrEmpty(blastMessage))
            {
                <div class="alert alert-@blastMessageType" style="margin-top: 10px;">@blastMessage</div>
            }
        </div>

        <!-- YouTube Video ID Setting -->
        <div class="card control-panel">
            <h2>üì∫ Stream Settings</h2>
            <div class="form-group">
                <label>Live Stream Video ID</label>
                <input type="text" @bind="videoId" placeholder="e.g., dQw4w9WgXcQ" 
                       style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); border-radius: 5px; color: var(--text);">
                <small style="color: var(--text-dim);">The video ID from your YouTube live stream URL</small>
            </div>
            <div style="display: flex; gap: 10px;">
                <button @onclick="SaveVideoId" class="btn-primary" style="flex: 1;">
                    üíæ Save Video ID
                </button>
                <button @onclick="LoginWithYouTube" class="btn-secondary" style="flex: 1;">
                    üîó Login with YouTube
                </button>
            </div>
            @if (!string.IsNullOrEmpty(videoMessage))
            {
                <div class="alert alert-@videoMessageType" style="margin-top: 10px;">@videoMessage</div>
            }
        </div>
    }

    <!-- Pending Links -->
    <div class="card moderation-section">
        <h2>üîó Incoming Links <span class="badge">@pendingImageCount</span></h2>
        <div style="margin-bottom: 15px;">
            <button @onclick="LoadPendingImages" class="btn-secondary">üîÑ Refresh</button>
            <label style="display: inline-flex; align-items: center; gap: 8px; margin-left: 10px; cursor: pointer;">
                <input type="checkbox" @bind="autoRefreshImages" @bind:after="ToggleAutoRefreshImages">
                <span style="color: var(--text-dim); font-size: 14px;">Auto (5s)</span>
            </label>
        </div>
        
        @if (pendingImages == null || !pendingImages.Any())
        {
            <div class="empty-state">‚úÖ No links pending</div>
        }
        else
        {
            <div class="image-list">
                @foreach (var img in pendingImages)
                {
                    <div class="image-card-compact">
                        <div class="image-info">
                            <span class="image-id">#@img.Id</span>
                            <span class="image-author">üë§ @img.Author</span>
                        </div>
                        <div class="image-prompt">@img.UserPrompt</div>
                        <div class="link-url" style="word-break: break-all; font-size: 12px; color: var(--info); margin-bottom: 10px;">üîó @img.ImageUrl</div>
                        <div class="image-actions">
                            <button @onclick="() => ApproveImage(img.Id)" class="btn-success btn-small">‚úÖ</button>
                            <button @onclick="() => DenyImage(img.Id)" class="btn-danger btn-small">‚ùå</button>
                        </div>
                    </div>
                }
            </div>
        }
    </div>

    <!-- Pending Refunds -->
    <div class="card moderation-section">
        <h2>üí∞ Refund Requests <span class="badge">@pendingRefundCount</span></h2>
        <button @onclick="LoadPendingRefunds" class="btn-secondary" style="margin-bottom: 15px;">üîÑ Refresh</button>
        
        @if (pendingRefunds == null || !pendingRefunds.Any())
        {
            <div class="empty-state">‚úÖ No refund requests</div>
        }
        else
        {
            <div class="refund-list">
                @foreach (var refund in pendingRefunds)
                {
                    <div class="refund-card-compact">
                        <div class="refund-info">
                            <span class="refund-id">#@refund.Id</span>
                            <span class="refund-user">üë§ @refund.UserDisplayName</span>
                            <span class="refund-amount">$@refund.Amount.ToString("F2")</span>
                        </div>
                        <div class="refund-reason"><strong>Reason:</strong> @refund.Reason</div>
                        <div class="refund-actions">
                            <button @onclick="() => ApproveRefund(refund.Id)" class="btn-success btn-small">‚úÖ Refund</button>
                            <button @onclick="() => DenyRefund(refund.Id)" class="btn-danger btn-small">‚ùå Deny</button>
                        </div>
                    </div>
                }
            </div>
        }
    </div>

    <!-- Global History (with spoiler dropdown) -->
    <div class="card history-section">
        <h2>üìú Global History</h2>
        <div style="margin-bottom: 15px;">
            <button @onclick="LoadHistory" class="btn-secondary">üîÑ Refresh</button>
            <label style="display: inline-flex; align-items: center; gap: 8px; margin-left: 10px; cursor: pointer;">
                <input type="checkbox" @bind="autoRefreshHistory" @bind:after="ToggleAutoRefreshHistory">
                <span style="color: var(--text-dim); font-size: 14px;">Auto (5s)</span>
            </label>
        </div>
        
        <details class="history-spoiler">
            <summary style="cursor: pointer; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; margin-bottom: 10px;">
                ‚ö†Ô∏è Click to reveal history (may spoil effects)
            </summary>
            
            @if (history == null || !history.Any())
            {
                <div class="empty-state">No commands in history yet.</div>
            }
            else
            {
                <div class="history-list">
                    @foreach (var cmd in history.Take(20))
                    {
                        <div class="history-item-compact">
                            <div style="flex: 1;">
                                <div class="history-meta">
                                    <span class="history-id">#@cmd.Id</span>
                                    <span class="history-time">@cmd.Timestamp.ToLocalTime().ToString("HH:mm:ss")</span>
                                    <span class="history-source">@cmd.Source</span>
                                </div>
                                <div class="history-prompt">üë§ @cmd.Author: @cmd.UserPrompt</div>
                                <span class="history-status status-@GetStatusClass(cmd.Status)">@GetStatusText(cmd.Status)</span>
                            </div>
                            <div class="history-actions-compact">
                                <button @onclick="() => UndoCommand(cmd.Id)" class="btn-warning btn-small" title="Undo">‚Ü©</button>
                                <button @onclick="() => ForceUndoCommand(cmd.Id)" class="btn-danger btn-small" title="Force Undo (Auto-generated)">üîß</button>
                                <button @onclick="() => OpenSavePayloadModal(cmd.Id)" class="btn-success btn-small" title="Save Payload">üíæ</button>
                            </div>
                        </div>
                    }
                    @if (history.Count > 20)
                    {
                        <div class="empty-state">Showing 20 most recent. View full history in History tab.</div>
                    }
                </div>
            }
        </details>
    </div>
</div>

<!-- Save Payload Modal -->
@if (showSavePayloadModal)
{
    <div class="modal active">
        <div class="modal-content">
            <h3>üíæ Save Payload</h3>
            <p>Enter a name for this saved payload:</p>
            <div class="form-group">
                <input type="text" @bind="payloadName" placeholder="Payload name..." style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); border-radius: 5px; color: var(--text);">
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                <button @onclick="CloseSavePayloadModal" class="btn-secondary">Cancel</button>
                <button @onclick="SavePayload" class="btn-primary">üíæ Save</button>
            </div>
        </div>
    </div>
}

<style>
    .stream-control-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
    }

    .control-panel {
        min-height: 200px;
    }

    .moderation-section,
    .history-section {
        grid-column: span 1;
    }

    .queue-stats {
        display: flex;
        gap: 20px;
        padding: 15px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
    }

    .stat-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .stat-label {
        font-size: 12px;
        color: var(--text-dim);
    }

    .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: var(--accent);
    }

    .badge {
        background: var(--accent);
        color: #000;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
        margin-left: 8px;
    }

    .image-list,
    .refund-list,
    .history-list {
        max-height: 400px;
        overflow-y: auto;
    }

    .image-card-compact,
    .refund-card-compact,
    .history-item-compact {
        padding: 10px;
        background: rgba(255,255,255,0.05);
        border-radius: 5px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
    }

    .image-info,
    .refund-info,
    .history-meta {
        display: flex;
        gap: 10px;
        font-size: 12px;
        color: var(--text-dim);
        margin-bottom: 5px;
    }

    .image-prompt,
    .refund-reason,
    .history-prompt {
        font-size: 14px;
        margin-bottom: 10px;
        color: var(--text);
    }

    .image-preview-small {
        max-width: 100%;
        max-height: 150px;
        border-radius: 5px;
        margin-bottom: 10px;
    }

    .image-actions,
    .refund-actions,
    .history-actions-compact {
        display: flex;
        gap: 5px;
    }

    .history-spoiler summary {
        font-weight: bold;
        color: var(--warning);
    }

    .history-status {
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        display: inline-block;
        margin-top: 5px;
    }

    .status-pending { background: #888; }
    .status-pendingmoderation { background: #ff9800; color: #000; }
    .status-queued { background: #f0ad4e; }
    .status-executed { background: #5cb85c; }
    .status-undone { background: #5bc0de; }
    .status-failed { background: #d9534f; }

    .empty-state {
        padding: 20px;
        text-align: center;
        color: var(--text-dim);
        font-style: italic;
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .modal.active {
        display: flex;
    }

    .modal-content {
        background: #1a1a1a;
        padding: 25px;
        border-radius: 10px;
        width: 90%;
        max-width: 500px;
        border: 1px solid var(--border);
    }
</style>

@code {
    [Parameter]
    public Account? CurrentAccount { get; set; }
    
    // Global message
    private string globalMessage = "";
    private string globalMessageType = "info";
    
    // Blast controls
    private int blastCount = 1;
    private string blastMessage = "";
    private string blastMessageType = "info";
    private int activeSlots = 0;
    private int totalSlots = 0;
    private CancellationTokenSource? blastMessageCts;

    // Video ID
    private string videoId = "";
    private string videoMessage = "";
    private string videoMessageType = "info";
    private CancellationTokenSource? videoMessageCts;

    // Images
    private List<PendingImageEntry>? pendingImages;
    private int pendingImageCount = 0;
    private bool autoRefreshImages = false;
    private System.Threading.Timer? imageRefreshTimer;

    // Refunds
    private List<RefundRequest>? pendingRefunds;
    private int pendingRefundCount = 0;

    // History
    private List<CommandEntry>? history;
    private bool autoRefreshHistory = false;
    private System.Threading.Timer? historyRefreshTimer;

    protected override async Task OnInitializedAsync()
    {
        // Check for query parameters (success/error messages)
        var uri = new Uri(Navigation.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        
        if (query["success"] != null)
        {
            globalMessage = query["success"]!;
            globalMessageType = "success";
        }
        else if (query["error"] != null)
        {
            globalMessage = query["error"]!;
            globalMessageType = "error";
        }
        
        await LoadAll();
    }

    private async Task LoadAll()
    {
        await LoadPendingImages();
        await LoadPendingRefunds();
        await LoadHistory();
        await LoadQueueStatus();
        LoadVideoId();
    }

    private async Task ManualBlast()
    {
        try
        {
            var count = Math.Max(1, Math.Min(blastCount, 10));
            var response = await Http.PostAsJsonAsync("/api/queue/blast", new { Count = count });
            
            if (response.IsSuccessStatusCode)
            {
                blastMessage = $"üí• Blasted {count} command(s)!";
                blastMessageType = "success";
                await LoadQueueStatus();
            }
            else
            {
                blastMessage = "Failed to blast queue";
                blastMessageType = "error";
            }
        }
        catch (Exception ex)
        {
            blastMessage = $"Error: {ex.Message}";
            blastMessageType = "error";
        }
        StateHasChanged();
        
        // Clear message after 3 seconds with cancellation support
        blastMessageCts?.Cancel();
        blastMessageCts = new CancellationTokenSource();
        var cts = blastMessageCts;
        
        try
        {
            await Task.Delay(3000, cts.Token);
            await InvokeAsync(() =>
            {
                if (!cts.IsCancellationRequested)
                {
                    blastMessage = "";
                    StateHasChanged();
                }
            });
        }
        catch (OperationCanceledException)
        {
            // Cancellation is expected when the user triggers a new blast or navigates away.
            // No action needed.
        }
    }

    private async Task LoadQueueStatus()
    {
        try
        {
            var response = await Http.GetFromJsonAsync<QueueSlotStatus>("/api/queue/status");
            if (response != null)
            {
                totalSlots = response.TotalSlots;
                activeSlots = response.OccupiedSlots;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load queue status: {ex.Message}");
        }
    }

    private void LoadVideoId()
    {
        try
        {
            var settings = SettingsService.Settings;
            videoId = settings.YouTube.VideoId ?? "";
        }
        catch { }
    }

    private async Task SaveVideoId()
    {
        try
        {
            var settings = SettingsService.Settings;
            settings.YouTube.VideoId = videoId;
            SettingsService.SaveSettings();
            
            // Automatically start listening to the video's chat
            if (!string.IsNullOrEmpty(videoId))
            {
                var started = await YouTubeService.StartListeningAsync(videoId);
                if (started)
                {
                    videoMessage = "‚úì Video ID saved and listening to chat";
                    videoMessageType = "success";
                }
                else
                {
                    videoMessage = "‚úì Video ID saved but failed to start listening (check YouTube setup)";
                    videoMessageType = "warning";
                }
            }
            else
            {
                videoMessage = "‚úì Video ID saved";
                videoMessageType = "success";
            }
        }
        catch (Exception ex)
        {
            videoMessage = $"Error: {ex.Message}";
            videoMessageType = "error";
        }
        StateHasChanged();
        
        // Clear message after 5 seconds to give user time to read the message
        videoMessageCts?.Cancel();
        videoMessageCts = new CancellationTokenSource();
        var cts = videoMessageCts;
        
        try
        {
            await Task.Delay(5000, cts.Token);
            if (!cts.IsCancellationRequested)
            {
                videoMessage = "";
                StateHasChanged();
            }
        }
        catch (OperationCanceledException) { }
    }

    private void LoginWithYouTube()
    {
        try
        {
            var redirectUri = $"{Navigation.BaseUri}api/setup/youtube/callback";
            var authUrl = YouTubeService.GetAuthorizationUrl(redirectUri);

            if (!string.IsNullOrEmpty(authUrl))
            {
                Navigation.NavigateTo(authUrl, true);
            }
            else
            {
                videoMessage = "Failed to get authorization URL - check YouTube setup";
                videoMessageType = "error";
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            videoMessage = $"Error: {ex.Message}";
            videoMessageType = "error";
            StateHasChanged();
        }
    }

    private async Task LoadPendingImages()
    {
        try
        {
            pendingImages = ModerationService.GetPendingImages();
            pendingImageCount = pendingImages?.Count ?? 0;
        }
        catch { }
        StateHasChanged();
    }

    private void ApproveImage(int imageId)
    {
        try
        {
            ModerationService.ApproveImage(imageId);
            Task.Run(async () => await LoadPendingImages()).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to approve image: {ex.Message}");
        }
    }

    private void DenyImage(int imageId)
    {
        try
        {
            ModerationService.DenyImage(imageId);
            Task.Run(async () => await LoadPendingImages()).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to deny image: {ex.Message}");
        }
    }

    private void ToggleAutoRefreshImages()
    {
        if (autoRefreshImages)
        {
            imageRefreshTimer = new System.Threading.Timer(async _ =>
            {
                await InvokeAsync(async () =>
                {
                    await LoadPendingImages();
                });
            }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
        }
        else
        {
            imageRefreshTimer?.Dispose();
            imageRefreshTimer = null;
        }
    }

    private async Task LoadPendingRefunds()
    {
        try
        {
            pendingRefunds = RefundService.GetPendingRequests();
            pendingRefundCount = pendingRefunds?.Count ?? 0;
        }
        catch { }
        StateHasChanged();
    }

    private void ApproveRefund(string refundId)
    {
        try
        {
            RefundService.ApproveRefund(refundId);
            Task.Run(async () => await LoadPendingRefunds()).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to approve refund: {ex.Message}");
        }
    }

    private void DenyRefund(string refundId)
    {
        try
        {
            RefundService.RejectRefund(refundId);
            Task.Run(async () => await LoadPendingRefunds()).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to deny refund: {ex.Message}");
        }
    }

    private async Task LoadHistory()
    {
        try
        {
            history = CommandQueue.GetHistory().OrderByDescending(c => c.Timestamp).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load history: {ex.Message}");
        }
        StateHasChanged();
    }

    private void ToggleAutoRefreshHistory()
    {
        if (autoRefreshHistory)
        {
            historyRefreshTimer = new System.Threading.Timer(async _ =>
            {
                await InvokeAsync(async () =>
                {
                    await LoadHistory();
                });
            }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
        }
        else
        {
            historyRefreshTimer?.Dispose();
            historyRefreshTimer = null;
        }
    }

    private string GetStatusClass(CommandStatus status) => status switch
    {
        CommandStatus.Executed => "executed",
        CommandStatus.Failed => "failed",
        CommandStatus.Queued => "queued",
        CommandStatus.Undone => "undone",
        CommandStatus.PendingModeration => "pendingmoderation",
        _ => "pending"
    };

    private string GetStatusText(CommandStatus status) => status.ToString();

    private void UndoCommand(int commandId)
    {
        try
        {
            CommandQueue.UndoCommand(commandId);
            Task.Run(async () => await LoadHistory()).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Undo failed: {ex.Message}");
        }
    }

    private async void ForceUndoCommand(int commandId)
    {
        try
        {
            var command = CommandQueue.GetCommand(commandId);
            if (command == null)
            {
                Console.WriteLine($"[FORCE UNDO] Command #{commandId} not found");
                return;
            }

            Console.WriteLine($"[FORCE UNDO] Generating AI-powered undo for command #{commandId}: {command.UserPrompt}");

            // We need to inject AiCodeGeneratorService
            // For now, just queue the undo code if it exists
            if (!string.IsNullOrEmpty(command.UndoCode))
            {
                CommandQueue.QueueCode(command.UndoCode);
                Console.WriteLine($"[FORCE UNDO] Undo queued for command #{commandId}");
                await LoadHistory();
            }
            else
            {
                Console.WriteLine($"[FORCE UNDO] No undo code available for command #{commandId}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Force undo failed: {ex.Message}");
        }
    }

    private bool showSavePayloadModal = false;
    private int selectedCommandIdForPayload = 0;
    private string payloadName = "";

    private void OpenSavePayloadModal(int commandId)
    {
        selectedCommandIdForPayload = commandId;
        var command = CommandQueue.GetCommand(commandId);
        payloadName = command?.UserPrompt ?? "";
        showSavePayloadModal = true;
        StateHasChanged();
    }

    private void CloseSavePayloadModal()
    {
        showSavePayloadModal = false;
        payloadName = "";
        selectedCommandIdForPayload = 0;
        StateHasChanged();
    }

    private async Task SavePayload()
    {
        try
        {
            var command = CommandQueue.GetCommand(selectedCommandIdForPayload);
            if (command != null && !string.IsNullOrEmpty(payloadName))
            {
                var response = await Http.PostAsJsonAsync("/api/setup/payloads", new
                {
                    Name = payloadName,
                    Prompt = command.UserPrompt,
                    Code = command.ExecutionCode,
                    UndoCode = command.UndoCode
                });

                if (response.IsSuccessStatusCode)
                {
                    Console.WriteLine($"Payload '{payloadName}' saved successfully");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Save payload failed: {ex.Message}");
        }
        finally
        {
            CloseSavePayloadModal();
        }
    }

    public void Dispose()
    {
        imageRefreshTimer?.Dispose();
        historyRefreshTimer?.Dispose();
        blastMessageCts?.Cancel();
        blastMessageCts?.Dispose();
        videoMessageCts?.Cancel();
        videoMessageCts?.Dispose();
    }
}
