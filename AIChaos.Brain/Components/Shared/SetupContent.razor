@inject SettingsService SettingsService
@inject TwitchService TwitchService
@inject YouTubeService YouTubeService
@inject TunnelService TunnelService
@inject IJSRuntime JS
@inject NavigationManager Navigation

<div id="alerts">
    @if (!string.IsNullOrEmpty(alertMessage))
    {
        <div class="alert alert-@alertType">@alertMessage</div>
    }
</div>

<!-- OpenRouter API -->
<div class="card">
    <h2>
        ü§ñ OpenRouter API
        <span class="status-badge @(openRouterConfigured ? "status-connected" : "status-disconnected")">
            @(openRouterConfigured ? "Configured" : "Not Configured")
        </span>
    </h2>
    <p style="color: var(--text-dim); margin-bottom: 15px;">
        OpenRouter provides access to language models for generating Lua code.
    </p>

    <div class="form-group">
        <label>API Key</label>
        <input type="password" @bind="openRouterApiKey" placeholder="sk-or-v1-...">
    </div>

    <div class="form-group">
        <label>Code Generator Model</label>
        <select @bind="selectedModel">
            @if (models == null || !models.Any())
            {
                <option value="">Loading models...</option>
            }
            else
            {
                @foreach (var model in models)
                {
                    <option value="@model.Id">@model.Name (@model.Provider)</option>
                }
            }
        </select>
        <small>Choose the language model for generating Lua code</small>
    </div>

    <button @onclick="SaveOpenRouter">üíæ Save OpenRouter Settings</button>
</div>

<!-- Tunnel Configuration -->
<div class="card">
    <h2>
        üåê Tunnel Configuration
        <span class="status-badge @(tunnelRunning ? "status-connected" : "status-disconnected")">
            @(tunnelRunning ? $"{tunnelType} Running" : "Not Running")
        </span>
    </h2>

    <div class="alert alert-warning" style="margin-bottom: 15px;">
        <strong>‚ö†Ô∏è Required for GMod:</strong> GMod does not allow local HTTP connections. You must start a tunnel for
        GMod to communicate with the brain.
    </div>

    @if (tunnelRunning && !string.IsNullOrEmpty(tunnelUrl))
    {
        <div class="tunnel-url">
            <strong>Public URL:</strong> <a href="@tunnelUrl" target="_blank">@tunnelUrl</a>
            <div style="margin-top: 5px; color: var(--text-dim); font-size: 12px;">
                Poll URL (for GMod): <code>@tunnelUrl/poll</code>
            </div>
            <div style="margin-top: 5px; color: var(--success); font-size: 12px;">
                ‚úÖ Lua file updated automatically - copy lua/ folder to your GMod addons
            </div>
        </div>
    }

    <div class="btn-group" style="margin-top: 15px;">
        @if (!tunnelRunning)
        {
            <button @onclick='() => StartTunnel("bore")' class="btn-success">üöÄ Start Bore</button>
            <button @onclick='() => StartTunnel("localtunnel")'>üöÄ Start LocalTunnel</button>
            <button @onclick='() => StartTunnel("ngrok")' class="btn-secondary">üöÄ Start ngrok</button>
        }
        else
        {
            <button @onclick="StopTunnel" class="btn-danger">‚èπÔ∏è Stop Tunnel</button>
        }
    </div>
</div>

<!-- Test Client Mode -->
<div class="card">
    <h2>
        üß™ AI-Driven Test Client Mode
        <span class="status-badge @GetTestClientStatusBadge()">
            @testClientStatusText
        </span>
    </h2>
    <div class="alert alert-info" style="margin-bottom: 15px;">
        <strong>‚ÑπÔ∏è About AI-Driven Test Client Mode:</strong> Run GMod with <code>-multirun</code> to have a separate
        test client receive and execute commands first.
    </div>

    <div class="form-group checkbox-group">
        <input type="checkbox" @bind="testClientEnabled" @bind:after="ToggleTestClientMode">
        <label style="margin: 0; font-weight: bold;">Enable AI-Driven Test Client Mode</label>
    </div>

    @if (testClientEnabled)
    {
        <div style="margin-top: 15px;">
            <div class="form-row">
                <div class="form-group">
                    <label>Test Map</label>
                    <input type="text" @bind="testClientMap" placeholder="gm_flatgrass">
                    <small>Small/fast-loading map for test client</small>
                </div>
                <div class="form-group">
                    <label>Timeout (seconds)</label>
                    <input type="number" @bind="testClientTimeout" min="5" max="60">
                    <small>How long to wait for test results</small>
                </div>
            </div>

            <button @onclick="SaveTestClientSettings" class="btn-secondary">üíæ Save Settings</button>
        </div>
    }
</div>

<!-- YouTube Integration -->
<div class="card">
    <h2>
        <span style="color: #ff0000;">üì∫</span> YouTube Integration
        <span class="status-badge @(youtubeConfigured ? "status-connected" : "status-disconnected")">
            @(youtubeConfigured ? "Connected" : "Not Connected")
        </span>
    </h2>
    <p style="color: var(--text-dim); margin-bottom: 15px;">
        Connect to YouTube to receive Super Chat commands from your live stream.
    </p>

    <div class="form-row">
        <div class="form-group">
            <label>Client ID</label>
            <input type="text" @bind="youtubeClientId" placeholder="Your Google Client ID">
        </div>
        <div class="form-group">
            <label>Client Secret</label>
            <input type="password" @bind="youtubeClientSecret" placeholder="Your Google Client Secret">
        </div>
    </div>

    <div class="form-group">
        <label>Minimum Super Chat ($)</label>
        <input type="number" @bind="youtubeMinAmount" min="0" step="0.01">
    </div>

    <div class="form-group checkbox-group">
        <input type="checkbox" @bind="youtubeAllowChat" id="youtubeAllowChat">
        <label for="youtubeAllowChat" style="margin: 0;">Also allow regular chat commands (not just Super Chats)</label>
    </div>

    <div class="form-group checkbox-group">
        <input type="checkbox" @bind="youtubeAllowViewerOAuth" id="youtubeAllowViewerOAuth">
        <label for="youtubeAllowViewerOAuth" style="margin: 0;">Allow viewers to link via Google Sign-In (first 100 users)</label>
        <small style="display: block; margin-left: 24px; color: var(--text-dim);">When disabled, viewers must use link codes only</small>
    </div>

    <div class="btn-group" style="margin-top: 15px;">
        <button @onclick="SaveYouTubeCredentials" class="btn-secondary">üíæ Save Credentials</button>
        <button @onclick="AuthorizeYouTube" class="youtube-btn">üîó Login with YouTube</button>
    </div>
    <p style="color: var(--text-dim); font-size: 12px; margin-top: 10px;">
        ‚ÑπÔ∏è Manage your active stream in the <strong>Stream Control</strong> tab
    </p>
</div>

<style>
    .status-badge {
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        margin-left: 10px;
    }

    .status-connected {
        background: var(--success);
        color: #000;
    }

    .status-disconnected {
        background: var(--error);
        color: #fff;
    }

    .status-pending {
        background: var(--warning);
        color: #000;
    }

    .tunnel-url {
        padding: 15px;
        background: rgba(0, 255, 0, 0.1);
        border-radius: 8px;
        margin: 15px 0;
    }

    .form-row {
        display: flex;
        gap: 20px;
    }

    .form-row .form-group {
        flex: 1;
    }

    .checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }
</style>

@code {
    private string alertMessage = "";
    private string alertType = "info";

    // OpenRouter
    private bool openRouterConfigured = false;
    private string openRouterApiKey = "";
    private string selectedModel = "";
    private List<Model>? models;

    // Tunnel
    private bool tunnelRunning = false;
    private string tunnelType = "";
    private string tunnelUrl = "";

    // Test Client
    private bool testClientEnabled = false;
    private string testClientStatusText = "Disabled";
    private string testClientMap = "gm_flatgrass";
    private int testClientTimeout = 10;

    // YouTube
    private bool youtubeConfigured = false;
    private string youtubeClientId = "";
    private string youtubeClientSecret = "";
    private decimal youtubeMinAmount = 1.00m;
    private bool youtubeAllowChat = false;
    private bool youtubeAllowViewerOAuth = true;

    protected override async Task OnInitializedAsync()
    {
        await LoadSetupStatus();
        LoadModels();
    }

    private Task LoadSetupStatus()
    {
        try
        {
            var settings = SettingsService.Settings;
            var tunnelStatus = TunnelService.GetStatus();

            openRouterConfigured = SettingsService.IsOpenRouterConfigured;

            tunnelRunning = tunnelStatus.IsRunning;
            tunnelType = tunnelStatus.Type.ToString();
            tunnelUrl = tunnelStatus.Url ?? "";

            testClientEnabled = settings.TestClient.Enabled;
            testClientStatusText = settings.TestClient.IsConnected ? "Connected" : (testClientEnabled ? "Enabled (Waiting)" :
            "Disabled");

            youtubeConfigured = SettingsService.IsYouTubeConfigured;
            youtubeAllowViewerOAuth = settings.YouTube.AllowViewerOAuth;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load setup status failed: {ex.Message}");
        }
        return Task.CompletedTask;
    }

    private void LoadModels()
    {
        // Hardcoded models list as in controller
        models = new List<Model>
{
new Model { Id = "anthropic/claude-sonnet-4.5", Name = "Claude Sonnet 4.5 (Recommended)", Provider = "Anthropic" },
new Model { Id = "anthropic/claude-haiku-4.5", Name = "Claude Haiku 4.5", Provider = "Anthropic" },
new Model { Id = "anthropic/claude-opus-4.5", Name = "Claude Opus 4.5", Provider = "Anthropic" },
new Model { Id = "anthropic/claude-3.5-sonnet", Name = "Claude 3.5 Sonnet", Provider = "Anthropic" },
new Model { Id = "openai/gpt-5.1-codex-mini", Name = "GPT-5.1 Codex Mini", Provider = "OpenAI" },
new Model { Id = "openai/gpt-5-nano", Name = "GPT-5 Nano", Provider = "OpenAI" },
new Model { Id = "openai/gpt-oss-120b", Name = "gpt-oss-120b", Provider = "OpenAI" },
new Model { Id = "google/gemini-3-pro-preview", Name = "Gemini 3 Pro Preview", Provider = "Google" },
new Model { Id = "google/gemini-2.5-flash", Name = "Gemini Flash 2.5", Provider = "Google" },
new Model { Id = "meta-llama/llama-3.1-70b-instruct", Name = "Llama 3.1 70B", Provider = "Meta" },
new Model { Id = "mistralai/mixtral-8x22b-instruct", Name = "Mixtral 8x22B", Provider = "Mistral" },
new Model { Id = "x-ai/grok-code-fast-1", Name = "Grok Code Fast 1", Provider = "xAI" },
new Model { Id = "x-ai/grok-4.1-fast:free", Name = "Grok 4.1 Fast (Free)", Provider = "xAI" }
};
        selectedModel = SettingsService.Settings.OpenRouter.Model ?? "";

        // Load OpenRouter API Key (masked)
        openRouterApiKey = SettingsService.Settings.OpenRouter.ApiKey ?? "";
    }

    private async Task SaveOpenRouter()
    {
        try
        {
            SettingsService.UpdateOpenRouter(openRouterApiKey, selectedModel);
            ShowAlert("OpenRouter settings saved!", "success");
            await LoadSetupStatus();
        }
        catch
        {
            ShowAlert("Error saving settings", "error");
        }
    }

    private async Task StartTunnel(string type)
    {
        ShowAlert($"Starting {type}...", "info");

        try
        {
            var (success, url, message) = await TunnelService.StartTunnelAsync(type);

            if (success)
            {
                ShowAlert($"{type} started: {url}", "success");
                await LoadSetupStatus();
            }
            else
            {
                ShowAlert(message ?? $"Failed to start {type}", "error");
            }
        }
        catch
        {
            ShowAlert("Error starting tunnel", "error");
        }
    }

    private async Task StopTunnel()
    {
        try
        {
            TunnelService.StopTunnel();
            ShowAlert("Tunnel stopped", "info");
            await LoadSetupStatus();
        }
        catch
        {
            ShowAlert("Error stopping tunnel", "error");
        }
    }

    private async Task ToggleTestClientMode()
    {
        try
        {
            SettingsService.UpdateTestClient(testClientEnabled);
            ShowAlert(testClientEnabled ? "Test Client Mode enabled!" : "Test Client Mode disabled", testClientEnabled ? "success" :
            "info");
            await LoadSetupStatus();
        }
        catch
        {
            testClientEnabled = !testClientEnabled; // Revert
            ShowAlert("Error toggling test client mode", "error");
        }
    }

    private void SaveTestClientSettings()
    {
        try
        {
            SettingsService.UpdateTestClientSettings(testClientMap, testClientTimeout);
            ShowAlert("Test client settings saved!", "success");
        }
        catch
        {
            ShowAlert("Error saving settings", "error");
        }
    }

    private async Task SaveYouTubeCredentials()
    {
        try
        {
            // Don't pass video ID anymore - that's managed in Stream Control
            SettingsService.UpdateYouTubeCredentials(youtubeClientId, youtubeClientSecret, "", youtubeMinAmount,
            youtubeAllowChat, youtubeAllowViewerOAuth);
            ShowAlert("YouTube credentials saved!", "success");
            await LoadSetupStatus();
        }
        catch
        {
            ShowAlert("Error saving YouTube credentials", "error");
        }
    }

    private void AuthorizeYouTube()
    {
        try
        {
            var redirectUri = $"{Navigation.BaseUri}api/setup/youtube/callback";
            var authUrl = YouTubeService.GetAuthorizationUrl(redirectUri);

            if (!string.IsNullOrEmpty(authUrl))
            {
                Navigation.NavigateTo(authUrl, true);
            }
            else
            {
                ShowAlert("Failed to get authorization URL", "error");
            }
        }
        catch
        {
            ShowAlert("Error initiating authorization", "error");
        }
    }

    private void ShowAlert(string message, string type)
    {
        InvokeAsync(() =>
        {
            alertMessage = message;
            alertType = type;
            StateHasChanged();
        });

        _ = Task.Delay(5000).ContinueWith(async _ =>
        {
            await InvokeAsync(() =>
    {
    if (alertMessage == message) // Only clear if it hasn't changed
    {
        alertMessage = "";
        StateHasChanged();
    }
            });
        });
    }

    private string GetTestClientStatusBadge()
    {
        if (!testClientEnabled) return "status-disconnected";
        return testClientStatusText.Contains("Connected") ? "status-connected" : "status-pending";
    }

    private class Model
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public string Provider { get; set; } = "";
    }
}
