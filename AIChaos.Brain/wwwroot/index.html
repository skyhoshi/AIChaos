<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chaos Control</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI CHAOS CONTROL</h1>
            <p>Control GMod through AI-powered chat commands</p>
        </div>
        
        <div class="nav">
            <a href="/" class="nav-link active">‚ö° Control Panel</a>
            <a href="/setup" class="nav-link">üîß Setup</a>
            <a href="/history" class="nav-link">üìú History</a>
        </div>
        
        <div class="card">
            <h2>Send Chaos Command</h2>
            <div class="form-group">
                <textarea id="promptInput" placeholder="Ex: Make everyone tiny, Spawn 10 headcrabs, Turn the screen upside down..."></textarea>
            </div>
            
            <div class="form-group" style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="interactiveMode" style="width: 18px; height: 18px;">
                    <span>üîÑ Interactive Mode</span>
                    <span style="color: var(--text-dim); font-size: 12px;">(AI can search models, test code, and fix errors automatically)</span>
                </label>
            </div>
            
            <button id="sendBtn" onclick="sendPrompt()">‚ö° SEND CHAOS</button>
            
            <div id="status" style="margin-top: 15px;"></div>
            
            <div id="interactiveStatus" class="hidden" style="margin-top: 15px; padding: 15px; background: rgba(0,255,0,0.1); border-radius: 8px;">
                <h4 style="margin: 0 0 10px 0;">üîÑ Interactive Session</h4>
                <div id="interactivePhase">Phase: <span class="phase-badge">Starting...</span></div>
                <div id="interactiveIteration">Iteration: <span>0/5</span></div>
                <div id="interactiveSteps" style="margin-top: 10px;"></div>
            </div>
        </div>
        
        <div class="card">
            <h2>üìã Recent Commands</h2>
            <div id="recentCommands">
                <div class="empty-state">Commands will appear here...</div>
            </div>
        </div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const promptInput = document.getElementById('promptInput');
        const sendBtn = document.getElementById('sendBtn');
        
        // Generate or retrieve a unique user ID for this browser
        function getUserId() {
            let userId = localStorage.getItem('aichaos_user_id');
            if (!userId) {
                userId = 'user_' + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);
                localStorage.setItem('aichaos_user_id', userId);
            }
            return userId;
        }
        
        const userId = getUserId();
        let currentInteractiveSessionId = null;
        let interactivePollingInterval = null;
        let currentMaxIterations = 5;
        
        function log(msg, type = 'normal') {
            const el = document.createElement('div');
            el.className = 'log-entry ' + type;
            el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            statusDiv.prepend(el);
        }
        
        async function sendPrompt() {
            const text = promptInput.value.trim();
            if (!text) return;
            
            const isInteractive = document.getElementById('interactiveMode').checked;
            
            promptInput.disabled = true;
            sendBtn.disabled = true;
            sendBtn.textContent = isInteractive ? "üîÑ STARTING SESSION..." : "‚è≥ GENERATING...";
            
            try {
                const endpoint = isInteractive ? '/trigger/interactive' : '/trigger';
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: text, 
                        userId: userId,
                        maxIterations: 5
                    })
                });
                
                const data = await response.json();
                
                if (isInteractive) {
                    handleInteractiveResponse(data, text);
                } else {
                    if (data.status === 'queued') {
                        log(`‚úì ${text}`, 'success');
                        if (data.aiResponse) {
                            log(`üí¨ AI: ${data.aiResponse}`, 'info');
                        }
                        loadRecentCommands();
                    } else if (data.status === 'ignored') {
                        log(`‚úó BLOCKED: ${data.message}`, 'error');
                    } else {
                        log(`‚úó ERROR: ${JSON.stringify(data)}`, 'error');
                    }
                    resetSendButton();
                }
            } catch (err) {
                log(`‚úó NETWORK ERROR: ${err.message}`, 'error');
                resetSendButton();
            }
            
            promptInput.value = '';
        }
        
        function resetSendButton() {
            promptInput.disabled = false;
            sendBtn.disabled = false;
            sendBtn.textContent = "‚ö° SEND CHAOS";
            promptInput.focus();
        }
        
        function handleInteractiveResponse(data, originalPrompt) {
            const statusContainer = document.getElementById('interactiveStatus');
            statusContainer.classList.remove('hidden');
            
            // Track max iterations from response if available
            if (data.maxIterations) {
                currentMaxIterations = data.maxIterations;
            }
            
            if (data.status === 'in_progress') {
                currentInteractiveSessionId = data.sessionId;
                log(`üîÑ Interactive session started: ${originalPrompt}`, 'info');
                updateInteractiveUI(data);
                startInteractivePolling(data.sessionId);
            } else if (data.status === 'complete') {
                log(`‚úì Interactive session completed: ${originalPrompt}`, 'success');
                updateInteractiveUI(data);
                finishInteractiveSession();
            } else if (data.status === 'failed') {
                log(`‚úó Interactive session failed: ${data.message}`, 'error');
                updateInteractiveUI(data);
                finishInteractiveSession();
            } else {
                log(`‚úó Interactive error: ${JSON.stringify(data)}`, 'error');
                finishInteractiveSession();
            }
        }
        
        function updateInteractiveUI(data) {
            document.querySelector('#interactivePhase .phase-badge').textContent = data.currentPhase || 'Unknown';
            document.querySelector('#interactiveIteration span').textContent = `${data.iteration || 0}/${currentMaxIterations}`;
            
            const stepsContainer = document.getElementById('interactiveSteps');
            if (data.steps && data.steps.length > 0) {
                stepsContainer.innerHTML = data.steps.map(step => `
                    <div class="interactive-step" style="margin: 5px 0; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 12px;">
                        <div><strong>Step ${step.stepNumber}:</strong> ${step.phase}</div>
                        ${step.aiThinking ? `<div style="color: var(--text-dim);">üí≠ ${escapeHtml(step.aiThinking.substring(0, 100))}${step.aiThinking.length > 100 ? '...' : ''}</div>` : ''}
                        ${step.success === true ? '<span style="color: var(--success);">‚úì Success</span>' : ''}
                        ${step.success === false ? `<span style="color: var(--error);">‚úó ${escapeHtml(step.error || 'Failed')}</span>` : ''}
                    </div>
                `).join('');
            }
        }
        
        function startInteractivePolling(sessionId) {
            // Poll every 2 seconds for session updates
            interactivePollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/interactive/${sessionId}`);
                    const data = await response.json();
                    
                    updateInteractiveUI(data);
                    
                    if (data.isComplete) {
                        if (data.status === 'complete') {
                            log(`‚úì Interactive session completed successfully!`, 'success');
                        } else {
                            log(`‚úó Interactive session failed after ${data.iteration} iterations`, 'error');
                        }
                        finishInteractiveSession();
                        loadRecentCommands();
                    }
                } catch (err) {
                    console.error('Error polling interactive session:', err);
                }
            }, 2000);
        }
        
        function finishInteractiveSession() {
            if (interactivePollingInterval) {
                clearInterval(interactivePollingInterval);
                interactivePollingInterval = null;
            }
            currentInteractiveSessionId = null;
            resetSendButton();
            
            // Hide the interactive status after a delay
            setTimeout(() => {
                document.getElementById('interactiveStatus').classList.add('hidden');
            }, 5000);
        }
        
        promptInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                sendPrompt();
            }
        });
        
        async function loadRecentCommands() {
            try {
                // Load only this user's commands
                const response = await fetch(`/api/history/user/${encodeURIComponent(userId)}`);
                const data = await response.json();
                
                const container = document.getElementById('recentCommands');
                const recent = data.history.slice(-10).reverse();
                
                if (recent.length === 0) {
                    container.innerHTML = '<div class="empty-state">Your commands will appear here...</div>';
                    return;
                }
                
                // Status enum mapping (handles both integer and string)
                const statusNames = ['Pending', 'Queued', 'Executed', 'Undone', 'Failed'];
                const getStatusName = (status) => typeof status === 'number' ? statusNames[status] || 'Unknown' : status;
                
                container.innerHTML = recent.map(cmd => {
                    const statusName = getStatusName(cmd.status);
                    return `
                    <div class="history-item">
                        <div style="flex: 1;">
                            <div class="history-time">${new Date(cmd.timestamp).toLocaleTimeString()}</div>
                            <div class="history-prompt">${escapeHtml(cmd.userPrompt)}</div>
                            ${cmd.aiResponse ? `<div class="history-response">üí¨ ${escapeHtml(cmd.aiResponse)}</div>` : ''}
                            ${statusName === 'Failed' && cmd.errorMessage ? `<div class="history-error">‚ö†Ô∏è ${escapeHtml(cmd.errorMessage)}</div>` : ''}
                        </div>
                        <span class="history-source ${cmd.source}">${cmd.source}</span>
                        <span class="history-status status-${statusName.toLowerCase()}">${statusName}</span>
                        <div class="history-actions">
                            <button onclick="repeatCommand(${cmd.id})" class="btn-info btn-small">üîÅ</button>
                            <button onclick="undoCommand(${cmd.id})" class="btn-warning btn-small">‚Ü©</button>
                        </div>
                    </div>
                `}).join('');
            } catch (err) {
                console.error('Failed to load recent commands:', err);
            }
        }
        
        async function repeatCommand(id) {
            try {
                const response = await fetch('/api/repeat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ commandId: id })
                });
                const data = await response.json();
                log(data.status === 'success' ? '‚úì Command repeated!' : `‚úó ${data.message}`, data.status === 'success' ? 'success' : 'error');
            } catch (err) {
                log('‚úó Network error', 'error');
            }
        }
        
        async function undoCommand(id) {
            try {
                const response = await fetch('/api/undo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ commandId: id })
                });
                const data = await response.json();
                log(data.status === 'success' ? '‚úì Command undone!' : `‚úó ${data.message}`, data.status === 'success' ? 'success' : 'error');
            } catch (err) {
                log('‚úó Network error', 'error');
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
        
        // Initial load
        loadRecentCommands();
        
        // Auto-refresh
        setInterval(loadRecentCommands, 5000);
    </script>
</body>
</html>
