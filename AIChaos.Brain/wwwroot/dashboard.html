<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chaos Dashboard (Admin)</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI CHAOS DASHBOARD</h1>
            <p>Admin Control Panel - Direct GMod Control</p>
        </div>
        
        <div class="nav">
            <a href="/" class="nav-link">üë• Viewer</a>
            <a href="/dashboard" class="nav-link active">‚ö° Dashboard</a>
            <a href="/setup" class="nav-link">üîß Setup</a>
            <a href="/history" class="nav-link">üìú History</a>
            <a href="/moderation" class="nav-link">üõ°Ô∏è Moderation</a>
        </div>
        
        <div class="card">
            <h2>Send Chaos Command</h2>
            <div class="form-group">
                <textarea id="promptInput" placeholder="Ex: Make everyone tiny, Spawn 10 headcrabs, Turn the screen upside down..."></textarea>
            </div>
            
            <div class="form-group" style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="interactiveMode" style="width: 18px; height: 18px;">
                    <span>üîÑ Interactive Mode</span>
                    <span style="color: var(--text-dim); font-size: 12px;">(AI can search models, test code, and fix errors automatically)</span>
                </label>
            </div>
            
            <button id="sendBtn" onclick="sendPrompt()">‚ö° SEND CHAOS</button>
            
            <div id="status" style="margin-top: 15px;"></div>
            
            <div id="interactiveStatus" class="hidden" style="margin-top: 15px; padding: 15px; background: rgba(0,255,0,0.1); border-radius: 8px; position: relative;">
                <button id="dismissInteractive" onclick="dismissInteractiveStatus()" style="position: absolute; top: 10px; right: 10px; background: transparent; border: 1px solid var(--text-dim); color: var(--text-dim); padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">‚úï Dismiss</button>
                <h4 style="margin: 0 0 10px 0;">üîÑ Interactive Session <span id="sessionStatus"></span></h4>
                <div id="interactivePhase">Phase: <span class="phase-badge">Starting...</span></div>
                <div id="interactiveIteration">Iteration: <span>0/5</span></div>
                <div id="interactiveSteps" style="margin-top: 10px;"></div>
            </div>
            
            <div id="testClientStatus" class="hidden" style="margin-top: 15px; padding: 15px; background: rgba(255,165,0,0.1); border-radius: 8px; position: relative;">
                <button onclick="dismissTestClientStatus()" style="position: absolute; top: 10px; right: 10px; background: transparent; border: 1px solid var(--text-dim); color: var(--text-dim); padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">‚úï Dismiss</button>
                <h4 style="margin: 0 0 10px 0;">üß™ Test Client <span id="testClientSessionStatus"></span></h4>
                <div id="testClientPrompt" style="margin-bottom: 10px; color: var(--text-dim); font-size: 12px;"></div>
                <div id="testClientPhase">Status: <span class="phase-badge">Queued for testing...</span></div>
                <div id="testClientAttempt">Attempt: <span>0/3</span></div>
                <div id="testClientSteps" style="margin-top: 10px;"></div>
            </div>
        </div>
        
        <div class="card">
            <h2>üìã Recent Commands</h2>
            <div id="recentCommands">
                <div class="empty-state">Commands will appear here...</div>
            </div>
        </div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const promptInput = document.getElementById('promptInput');
        const sendBtn = document.getElementById('sendBtn');
        
        // Generate or retrieve a unique user ID for this browser
        function getUserId() {
            let userId = localStorage.getItem('aichaos_user_id');
            if (!userId) {
                userId = 'user_' + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);
                localStorage.setItem('aichaos_user_id', userId);
            }
            return userId;
        }
        
        const userId = getUserId();
        let currentInteractiveSessionId = null;
        let interactivePollingInterval = null;
        let currentMaxIterations = 5;
        
        function log(msg, type = 'normal') {
            const el = document.createElement('div');
            el.className = 'log-entry ' + type;
            el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            statusDiv.prepend(el);
        }
        
        async function sendPrompt() {
            const text = promptInput.value.trim();
            if (!text) return;
            
            const isInteractive = document.getElementById('interactiveMode').checked;
            
            promptInput.disabled = true;
            sendBtn.disabled = true;
            sendBtn.textContent = isInteractive ? "üîÑ STARTING SESSION..." : "‚è≥ GENERATING...";
            
            try {
                const endpoint = isInteractive ? '/trigger/interactive' : '/trigger';
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: text, 
                        userId: userId,
                        maxIterations: 5
                    })
                });
                
                const data = await response.json();
                
                if (isInteractive) {
                    handleInteractiveResponse(data, text);
                } else {
                    if (data.status === 'queued') {
                        log(`‚úì ${text}`, 'success');
                        if (data.aiResponse) {
                            log(`üí¨ AI: ${data.aiResponse}`, 'info');
                        }
                        loadRecentCommands();
                    } else if (data.status === 'testing') {
                        // Test client mode - show test client UI
                        handleTestClientResponse(data, text);
                    } else if (data.status === 'ignored') {
                        log(`‚úó BLOCKED: ${data.message}`, 'error');
                    } else {
                        log(`‚úó ERROR: ${JSON.stringify(data)}`, 'error');
                    }
                    resetSendButton();
                }
            } catch (err) {
                log(`‚úó NETWORK ERROR: ${err.message}`, 'error');
                resetSendButton();
            }
            
            promptInput.value = '';
        }
        
        function resetSendButton() {
            promptInput.disabled = false;
            sendBtn.disabled = false;
            sendBtn.textContent = "‚ö° SEND CHAOS";
            promptInput.focus();
        }
        
        function handleInteractiveResponse(data, originalPrompt) {
            const statusContainer = document.getElementById('interactiveStatus');
            statusContainer.classList.remove('hidden');
            
            // Track max iterations from response if available
            if (data.maxIterations) {
                currentMaxIterations = data.maxIterations;
            }
            
            if (data.status === 'in_progress') {
                currentInteractiveSessionId = data.sessionId;
                log(`üîÑ Interactive session started: ${originalPrompt}`, 'info');
                updateInteractiveUI(data);
                startInteractivePolling(data.sessionId);
            } else if (data.status === 'complete') {
                log(`‚úì Interactive session completed: ${originalPrompt}`, 'success');
                updateInteractiveUI(data);
                finishInteractiveSession();
            } else if (data.status === 'failed') {
                log(`‚úó Interactive session failed: ${data.message}`, 'error');
                updateInteractiveUI(data);
                finishInteractiveSession();
            } else {
                log(`‚úó Interactive error: ${JSON.stringify(data)}`, 'error');
                finishInteractiveSession();
            }
        }
        
        function updateInteractiveUI(data) {
            document.querySelector('#interactivePhase .phase-badge').textContent = data.currentPhase || 'Unknown';
            document.querySelector('#interactiveIteration span').textContent = `${data.iteration || 0}/${currentMaxIterations}`;
            
            // Update session status indicator
            const sessionStatusEl = document.getElementById('sessionStatus');
            if (data.isComplete) {
                if (data.status === 'complete') {
                    sessionStatusEl.innerHTML = '<span style="color: var(--success); font-size: 12px;">‚úì Complete</span>';
                } else {
                    sessionStatusEl.innerHTML = '<span style="color: var(--error); font-size: 12px;">‚úó Failed</span>';
                }
            } else {
                sessionStatusEl.innerHTML = '<span style="color: var(--warning); font-size: 12px;">‚è≥ In Progress</span>';
            }
            
            const stepsContainer = document.getElementById('interactiveSteps');
            if (data.steps && data.steps.length > 0) {
                stepsContainer.innerHTML = data.steps.map(step => `
                    <div class="interactive-step" style="margin: 5px 0; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 12px;">
                        <div><strong>Step ${step.stepNumber}:</strong> ${step.phase}</div>
                        ${step.aiThinking ? `<div style="color: var(--text-dim);">üí≠ ${escapeHtml(step.aiThinking.substring(0, 100))}${step.aiThinking.length > 100 ? '...' : ''}</div>` : ''}
                        ${step.success === true ? '<span style="color: var(--success);">‚úì Success</span>' : ''}
                        ${step.success === false ? `<span style="color: var(--error);">‚úó ${escapeHtml(step.error || 'Failed')}</span>` : ''}
                    </div>
                `).join('');
            }
        }
        
        function startInteractivePolling(sessionId) {
            // Poll every 2 seconds for session updates
            interactivePollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/interactive/${sessionId}`);
                    const data = await response.json();
                    
                    updateInteractiveUI(data);
                    
                    if (data.isComplete) {
                        if (data.status === 'complete') {
                            log(`‚úì Interactive session completed successfully!`, 'success');
                        } else {
                            log(`‚úó Interactive session failed after ${data.iteration} iterations`, 'error');
                        }
                        finishInteractiveSession();
                        loadRecentCommands();
                    }
                } catch (err) {
                    console.error('Error polling interactive session:', err);
                }
            }, 2000);
        }
        
        function finishInteractiveSession() {
            if (interactivePollingInterval) {
                clearInterval(interactivePollingInterval);
                interactivePollingInterval = null;
            }
            currentInteractiveSessionId = null;
            resetSendButton();
            
            // Keep the session visible - user can dismiss it manually or it will be replaced by the next session
        }
        
        function dismissInteractiveStatus() {
            document.getElementById('interactiveStatus').classList.add('hidden');
        }
        
        // Test Client Mode handling
        let testClientPollingInterval = null;
        let currentTestCommandId = null;
        let testClientSteps = [];
        
        function handleTestClientResponse(data, originalPrompt) {
            const statusContainer = document.getElementById('testClientStatus');
            statusContainer.classList.remove('hidden');
            
            currentTestCommandId = data.commandId;
            testClientSteps = [{
                stepNumber: 1,
                phase: 'Queued',
                thinking: 'Code generated, sending to test client...',
                success: null
            }];
            
            log(`üß™ Testing: ${originalPrompt}`, 'info');
            
            document.getElementById('testClientPrompt').textContent = `"${originalPrompt}"`;
            updateTestClientUI({
                phase: 'Queued',
                attempt: 0,
                maxAttempts: 3,
                steps: testClientSteps
            });
            
            startTestClientPolling(data.commandId, originalPrompt);
        }
        
        function updateTestClientUI(data) {
            document.querySelector('#testClientPhase .phase-badge').textContent = data.phase || 'Unknown';
            document.querySelector('#testClientAttempt span').textContent = `${data.attempt || 0}/${data.maxAttempts || 3}`;
            
            const sessionStatusEl = document.getElementById('testClientSessionStatus');
            if (data.phase === 'Approved') {
                sessionStatusEl.innerHTML = '<span style="color: var(--success); font-size: 12px;">‚úì Approved</span>';
            } else if (data.phase === 'Rejected') {
                sessionStatusEl.innerHTML = '<span style="color: var(--error); font-size: 12px;">‚úó Rejected</span>';
            } else if (data.phase === 'Testing') {
                sessionStatusEl.innerHTML = '<span style="color: var(--warning); font-size: 12px;">‚è≥ Testing</span>';
            } else if (data.phase === 'Fixing') {
                sessionStatusEl.innerHTML = '<span style="color: #ff9800; font-size: 12px;">üîß AI Fixing</span>';
            } else {
                sessionStatusEl.innerHTML = '<span style="color: var(--text-dim); font-size: 12px;">‚è≥ Queued</span>';
            }
            
            const stepsContainer = document.getElementById('testClientSteps');
            if (data.steps && data.steps.length > 0) {
                stepsContainer.innerHTML = data.steps.map(step => `
                    <div class="test-step" style="margin: 5px 0; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 12px;">
                        <div><strong>Step ${step.stepNumber}:</strong> ${step.phase}</div>
                        ${step.thinking ? `<div style="color: var(--text-dim);">üí≠ ${escapeHtml(step.thinking.substring(0, 100))}${step.thinking.length > 100 ? '...' : ''}</div>` : ''}
                        ${step.success === true ? '<span style="color: var(--success);">‚úì Success</span>' : ''}
                        ${step.success === false ? `<span style="color: var(--error);">‚úó ${escapeHtml(step.error || 'Failed')}</span>` : ''}
                    </div>
                `).join('');
            }
        }
        
        function startTestClientPolling(commandId, originalPrompt) {
            let pollCount = 0;
            const maxPolls = 60; // 2 minutes max polling
            
            testClientPollingInterval = setInterval(async () => {
                pollCount++;
                if (pollCount > maxPolls) {
                    finishTestClientSession('Timeout - test client not responding');
                    return;
                }
                
                try {
                    // Check test queue status
                    const response = await fetch('/api/test-client/status');
                    const data = await response.json();
                    
                    // Find our command in the status
                    const isPending = data.pendingCount > 0;
                    const isQueued = data.queuedCount > 0;
                    const hasApproved = data.approvedCount > 0;
                    
                    if (!data.isConnected) {
                        updateTestClientUI({
                            phase: 'Waiting for test client...',
                            attempt: testClientSteps.length,
                            maxAttempts: 3,
                            steps: testClientSteps
                        });
                        return;
                    }
                    
                    if (isPending) {
                        // Currently being tested
                        if (testClientSteps[testClientSteps.length - 1]?.phase !== 'Testing') {
                            testClientSteps.push({
                                stepNumber: testClientSteps.length + 1,
                                phase: 'Testing',
                                thinking: 'Executing code on test client...',
                                success: null
                            });
                        }
                        updateTestClientUI({
                            phase: 'Testing',
                            attempt: testClientSteps.length,
                            maxAttempts: 3,
                            steps: testClientSteps
                        });
                    } else if (isQueued) {
                        // Might be retrying with AI fix
                        const lastStep = testClientSteps[testClientSteps.length - 1];
                        if (lastStep && lastStep.phase === 'Testing' && lastStep.success === null) {
                            lastStep.success = false;
                            lastStep.error = 'Code error - AI is fixing...';
                            testClientSteps.push({
                                stepNumber: testClientSteps.length + 1,
                                phase: 'AI Fixing',
                                thinking: 'AI analyzing error and generating fix...',
                                success: null
                            });
                        }
                        updateTestClientUI({
                            phase: 'Fixing',
                            attempt: testClientSteps.length,
                            maxAttempts: 3,
                            steps: testClientSteps
                        });
                    } else if (!isPending && !isQueued) {
                        // Command completed (either approved or rejected)
                        // Check the history to see if our command was executed
                        const historyResponse = await fetch('/api/history');
                        const historyData = await historyResponse.json();
                        const ourCommand = historyData.history.find(c => c.id === commandId);
                        
                        if (ourCommand) {
                            const wasApproved = ourCommand.status === 'Queued' || ourCommand.status === 'Executed' || ourCommand.status === 2 || ourCommand.status === 1;
                            const lastStep = testClientSteps[testClientSteps.length - 1];
                            if (lastStep) {
                                lastStep.success = wasApproved;
                                if (!wasApproved) {
                                    lastStep.error = 'All fix attempts failed';
                                }
                            }
                            
                            testClientSteps.push({
                                stepNumber: testClientSteps.length + 1,
                                phase: wasApproved ? 'Approved' : 'Rejected',
                                thinking: wasApproved ? 'Code passed testing, sent to main client!' : 'Code failed all attempts, not sent to main client.',
                                success: wasApproved
                            });
                            
                            updateTestClientUI({
                                phase: wasApproved ? 'Approved' : 'Rejected',
                                attempt: testClientSteps.length,
                                maxAttempts: 3,
                                steps: testClientSteps
                            });
                            
                            if (wasApproved) {
                                log(`‚úì Test passed! Code sent to main client.`, 'success');
                            } else {
                                log(`‚úó Test failed. Code not sent to main client.`, 'error');
                            }
                            
                            finishTestClientSession();
                            loadRecentCommands();
                        }
                    }
                } catch (err) {
                    console.error('Error polling test client status:', err);
                }
            }, 2000);
        }
        
        function finishTestClientSession(errorMessage) {
            if (testClientPollingInterval) {
                clearInterval(testClientPollingInterval);
                testClientPollingInterval = null;
            }
            currentTestCommandId = null;
            
            if (errorMessage) {
                log(`‚úó ${errorMessage}`, 'error');
                testClientSteps.push({
                    stepNumber: testClientSteps.length + 1,
                    phase: 'Error',
                    thinking: errorMessage,
                    success: false,
                    error: errorMessage
                });
                updateTestClientUI({
                    phase: 'Error',
                    attempt: testClientSteps.length,
                    maxAttempts: 3,
                    steps: testClientSteps
                });
            }
        }
        
        function dismissTestClientStatus() {
            document.getElementById('testClientStatus').classList.add('hidden');
            if (testClientPollingInterval) {
                clearInterval(testClientPollingInterval);
                testClientPollingInterval = null;
            }
        }
        
        promptInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                sendPrompt();
            }
        });
        
        async function loadRecentCommands() {
            try {
                // Load only this user's commands
                const response = await fetch(`/api/history/user/${encodeURIComponent(userId)}`);
                const data = await response.json();
                
                const container = document.getElementById('recentCommands');
                const recent = data.history.slice(-10).reverse();
                
                if (recent.length === 0) {
                    container.innerHTML = '<div class="empty-state">Your commands will appear here...</div>';
                    return;
                }
                
                // Status enum mapping (handles both integer and string)
                const statusNames = ['Pending', 'Queued', 'Executed', 'Undone', 'Failed'];
                const getStatusName = (status) => typeof status === 'number' ? statusNames[status] || 'Unknown' : status;
                
                container.innerHTML = recent.map(cmd => {
                    const statusName = getStatusName(cmd.status);
                    return `
                    <div class="history-item">
                        <div style="flex: 1;">
                            <div class="history-time">${new Date(cmd.timestamp).toLocaleTimeString()}</div>
                            <div class="history-prompt">${escapeHtml(cmd.userPrompt)}</div>
                            ${cmd.aiResponse ? `<div class="history-response">üí¨ ${escapeHtml(cmd.aiResponse)}</div>` : ''}
                            ${statusName === 'Failed' && cmd.errorMessage ? `<div class="history-error">‚ö†Ô∏è ${escapeHtml(cmd.errorMessage)}</div>` : ''}
                        </div>
                        <span class="history-source ${cmd.source}">${cmd.source}</span>
                        <span class="history-status status-${statusName.toLowerCase()}">${statusName}</span>
                        <div class="history-actions">
                            <button onclick="repeatCommand(${cmd.id})" class="btn-info btn-small">üîÅ</button>
                            <button onclick="undoCommand(${cmd.id})" class="btn-warning btn-small">‚Ü©</button>
                        </div>
                    </div>
                `}).join('');
            } catch (err) {
                console.error('Failed to load recent commands:', err);
            }
        }
        
        async function repeatCommand(id) {
            try {
                const response = await fetch('/api/repeat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ commandId: id })
                });
                const data = await response.json();
                log(data.status === 'success' ? '‚úì Command repeated!' : `‚úó ${data.message}`, data.status === 'success' ? 'success' : 'error');
            } catch (err) {
                log('‚úó Network error', 'error');
            }
        }
        
        async function undoCommand(id) {
            try {
                const response = await fetch('/api/undo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ commandId: id })
                });
                const data = await response.json();
                log(data.status === 'success' ? '‚úì Command undone!' : `‚úó ${data.message}`, data.status === 'success' ? 'success' : 'error');
            } catch (err) {
                log('‚úó Network error', 'error');
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
        
        // Initial load
        loadRecentCommands();
        
        // Auto-refresh
        setInterval(loadRecentCommands, 5000);
    </script>
</body>
</html>
