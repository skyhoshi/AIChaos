<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chaos - Setup</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI CHAOS CONTROL</h1>
            <p>Control GMod through AI-powered chat commands</p>
        </div>
        
        <div class="nav">
            <a href="/" class="nav-link">‚ö° Control Panel</a>
            <a href="/setup" class="nav-link active">üîß Setup</a>
            <a href="/history" class="nav-link">üìú History</a>
        </div>
        
        <!-- Login Screen -->
        <div id="loginScreen" class="login-container">
            <div class="card">
                <h2>üîí Admin Access Required</h2>
                <div id="loginAlert"></div>
                
                <div id="setPasswordForm" class="hidden">
                    <p style="color: var(--text-dim);">Set your admin password to continue:</p>
                    <div class="form-group">
                        <label>New Password</label>
                        <input type="password" id="newPassword" placeholder="Enter password (min 4 chars)">
                    </div>
                    <div class="form-group">
                        <label>Confirm Password</label>
                        <input type="password" id="confirmPassword" placeholder="Confirm password">
                    </div>
                    <button onclick="setPassword()">Set Password</button>
                </div>
                
                <div id="loginForm">
                    <div class="form-group">
                        <label>Password</label>
                        <input type="password" id="loginPassword" placeholder="Enter admin password" onkeydown="if(event.key==='Enter')login()">
                    </div>
                    <button onclick="login()">üîì Login</button>
                </div>
            </div>
        </div>
        
        <!-- Setup Content (hidden until logged in) -->
        <div id="setupContent" class="hidden">
            <div id="alerts"></div>
            
            <!-- Admin Password -->
            <div class="card">
                <h2>üîë Admin Password</h2>
                <p style="color: var(--text-dim);">Change the admin password for Setup and History pages.</p>
                <div class="form-row">
                    <div class="form-group">
                        <label>Current Password</label>
                        <input type="password" id="currentPassword" placeholder="Current password">
                    </div>
                    <div class="form-group">
                        <label>New Password</label>
                        <input type="password" id="changePassword" placeholder="New password">
                    </div>
                </div>
                <button onclick="changePassword()" class="btn-secondary">üîÑ Change Password</button>
            </div>
            
            <!-- Private Discord Mode -->
            <div class="card">
                <h2>
                    üîì Private Discord Mode
                    <span id="privateDiscordModeStatus" class="status-badge status-disconnected">Disabled</span>
                </h2>
                <div class="alert alert-danger" style="margin-bottom: 15px;">
                    <strong>‚ö†Ô∏è WARNING:</strong> When enabled, this mode disables ALL safety filters and restrictions in the AI prompt. The AI will execute any request without limitations. Only enable this for private/trusted sessions!
                </div>
                <div class="form-group checkbox-group">
                    <input type="checkbox" id="privateDiscordModeToggle" onchange="togglePrivateDiscordMode()">
                    <label for="privateDiscordModeToggle" style="margin: 0; font-weight: bold;">Enable Private Discord Mode (No Filters)</label>
                </div>
            </div>
            
            <!-- Super Chat Simulator -->
            <div class="card">
                <h2>üí∞ Super Chat Simulator</h2>
                <p style="color: var(--text-dim); margin-bottom: 15px;">
                    Simulate a YouTube Super Chat to add credits to a user's account for testing.
                </p>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Username</label>
                        <input type="text" id="superChatUserId" placeholder="e.g., testuser123">
                        <small>The user's account username (they can find this on the viewer page top-right)</small>
                    </div>
                    <div class="form-group">
                        <label>Display Name</label>
                        <input type="text" id="superChatDisplayName" placeholder="e.g., TestUser">
                    </div>
                </div>
                <div class="form-group">
                    <label>Amount (USD)</label>
                    <input type="number" id="superChatAmount" value="5.00" min="0.01" step="0.01" placeholder="5.00">
                </div>
                
                <button onclick="simulateSuperChat()">üíµ Simulate Super Chat</button>
                <div id="superChatResult" style="margin-top: 10px;"></div>
            </div>
            
            <!-- YouTube API Simulator -->
            <div class="card">
                <h2>üì∫ YouTube API Simulator</h2>
                <p style="color: var(--text-dim); margin-bottom: 15px;">
                    Simulate a raw YouTube API Super Chat callback for testing channel linking and pending credits.
                </p>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>YouTube Channel ID</label>
                        <input type="text" id="ytApiChannelId" placeholder="UC...">
                        <small>The YouTube channel ID (not username)</small>
                    </div>
                    <div class="form-group">
                        <label>Display Name</label>
                        <input type="text" id="ytApiDisplayName" placeholder="Channel Name">
                    </div>
                </div>
                <div class="form-group">
                    <label>Message (Optional)</label>
                    <input type="text" id="ytApiMessage" placeholder="Optional message or LINK-CODE">
                </div>
                <div class="form-group">
                    <label>Amount (USD)</label>
                    <input type="number" id="ytApiAmount" value="5.00" min="0.01" step="0.01" placeholder="5.00">
                </div>
                
                <button onclick="simulateYouTubeApi()">üì∫ Simulate YouTube API Call</button>
                <div id="ytApiResult" style="margin-top: 10px;"></div>
            </div>
            
            <!-- OpenRouter API -->
            <div class="card">
                <h2>
                    ü§ñ OpenRouter API
                    <span id="openrouterStatus" class="status-badge status-disconnected">Not Configured</span>
                </h2>
                <p style="color: var(--text-dim); margin-bottom: 15px;">
                    OpenRouter provides access to AI models for generating Lua code.
                </p>
                
                <div class="setup-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Get an API Key</h4>
                        <p>Visit <a href="https://openrouter.ai/keys" target="_blank" style="color: var(--info);">openrouter.ai/keys</a> to create an account and generate an API key.</p>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>API Key</label>
                    <input type="password" id="openrouterApiKey" placeholder="sk-or-v1-...">
                </div>
                
                <div class="form-group">
                    <label>AI Model</label>
                    <select id="openrouterModel">
                        <option value="">Loading models...</option>
                    </select>
                    <small>Choose the AI model for generating Lua code</small>
                </div>
                
                <button onclick="saveOpenRouter()">üíæ Save OpenRouter Settings</button>
            </div>
            
            <!-- Tunnel Configuration -->
            <div class="card">
                <h2>
                    üåê Tunnel Configuration
                    <span id="tunnelStatus" class="status-badge status-disconnected">Not Running</span>
                </h2>
                
                <div class="alert alert-warning" style="margin-bottom: 15px;">
                    <strong>‚ö†Ô∏è Required for GMod:</strong> GMod does not allow local HTTP connections. You must start a tunnel for GMod to communicate with the brain. The Lua file will be automatically updated with the tunnel URL.
                </div>
                
                <div id="tunnelUrl" class="tunnel-url hidden">
                    <strong>Public URL:</strong> <a id="tunnelUrlLink" href="#" target="_blank"></a>
                    <div style="margin-top: 5px; color: var(--text-dim); font-size: 12px;">
                        Poll URL (for GMod): <code id="pollUrl"></code>
                    </div>
                    <div style="margin-top: 5px; color: var(--success); font-size: 12px;">
                        ‚úÖ Lua file updated automatically - copy lua/ folder to your GMod addons
                    </div>
                </div>
                
                <div id="publicIpInfo" class="alert alert-info hidden">
                    <strong>LocalTunnel Password:</strong> When first visiting, enter your public IP: <code id="publicIp"></code>
                </div>
                
                <!-- Tunnel Comparison Table -->
                <h4 style="margin-top: 20px; color: var(--accent);">Choose a Tunnel Service</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 14px;">
                    <thead>
                        <tr style="background: rgba(0,255,0,0.1);">
                            <th style="padding: 10px; text-align: left; border: 1px solid var(--border);">Feature</th>
                            <th style="padding: 10px; text-align: center; border: 1px solid var(--border);">üöÄ Bore</th>
                            <th style="padding: 10px; text-align: center; border: 1px solid var(--border);">üì¶ LocalTunnel</th>
                            <th style="padding: 10px; text-align: center; border: 1px solid var(--border);">üîß ngrok</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Account Required</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--success);">‚ùå No</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--success);">‚ùå No</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--warning);">‚úÖ Yes (free tier)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Password Page for Visitors</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--success);">‚ùå No</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--warning);">‚úÖ Yes (IP needed)</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--success);">‚ùå No</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Setup Complexity</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border);">Medium (Rust)</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border);">Easy (npm)</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border);">Easy (download)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Stability</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border);">Good</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border);">Good</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid var(--border); color: var(--success);">Best</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Install Command</td>
                            <td style="padding: 8px; border: 1px solid var(--border);"><code>cargo install bore-cli</code></td>
                            <td style="padding: 8px; border: 1px solid var(--border);"><code>npm install -g localtunnel</code></td>
                            <td style="padding: 8px; border: 1px solid var(--border);"><a href="https://ngrok.com/download" target="_blank" style="color: var(--info);">ngrok.com/download</a></td>
                        </tr>
                    </tbody>
                </table>
                
                <p style="color: var(--text-dim); font-size: 13px; margin-bottom: 15px;">
                    <strong>Recommendation:</strong> Use <strong>Bore</strong> for the simplest experience (no account, no password page). Use <strong>ngrok</strong> for the most stable connection (requires free account setup once).
                </p>
                
                <div class="btn-group">
                    <button onclick="startBore()" id="boreStartBtn" class="btn-success">üöÄ Start Bore</button>
                    <button onclick="startLocalTunnel()" id="ltStartBtn">üöÄ Start LocalTunnel</button>
                    <button onclick="startNgrok()" id="ngrokStartBtn" class="btn-secondary">üöÄ Start ngrok</button>
                    <button onclick="stopTunnel()" id="tunnelStopBtn" class="btn-danger hidden">‚èπÔ∏è Stop Tunnel</button>
                </div>
                
                <div id="tunnelError" class="alert alert-danger hidden" style="margin-top: 15px;"></div>
            </div>
            
            <!-- Twitch Integration -->
            <div class="card">
                <h2>
                    <span style="color: #9146ff;">üì∫</span> Twitch Integration
                    <span id="twitchStatus" class="status-badge status-disconnected">Not Connected</span>
                </h2>
                <p style="color: var(--text-dim); margin-bottom: 15px;">
                    Connect to Twitch to receive chaos commands from your chat.
                </p>
                
                <div class="setup-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Create a Twitch Application</h4>
                        <p>Go to <a href="https://dev.twitch.tv/console/apps" target="_blank" style="color: var(--info);">dev.twitch.tv/console</a> and create a new application. Set the OAuth Redirect URL to: <code id="twitchRedirectUrl">Loading...</code></p>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Client ID</label>
                        <input type="text" id="twitchClientId" placeholder="Your Twitch Client ID">
                    </div>
                    <div class="form-group">
                        <label>Client Secret</label>
                        <input type="password" id="twitchClientSecret" placeholder="Your Twitch Client Secret">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Channel Name</label>
                        <input type="text" id="twitchChannel" placeholder="Your channel name">
                    </div>
                    <div class="form-group">
                        <label>Chat Command</label>
                        <input type="text" id="twitchCommand" value="!chaos" placeholder="!chaos">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group checkbox-group">
                        <input type="checkbox" id="twitchRequireBits">
                        <label for="twitchRequireBits" style="margin: 0;">Require Bits</label>
                    </div>
                    <div class="form-group">
                        <label>Minimum Bits</label>
                        <input type="number" id="twitchMinBits" value="100" min="1">
                    </div>
                </div>
                
                <div class="btn-group">
                    <button onclick="saveTwitchCredentials()" class="btn-secondary">üíæ Save Credentials</button>
                    <button onclick="authorizeTwitch()" class="twitch-btn">üîó Login with Twitch</button>
                    <button onclick="connectTwitch()" id="twitchConnectBtn" class="btn-info">‚ñ∂Ô∏è Start Listening</button>
                    <button onclick="disconnectTwitch()" id="twitchDisconnectBtn" class="btn-danger hidden">‚èπÔ∏è Stop</button>
                </div>
            </div>
            
            <!-- YouTube Integration -->
            <div class="card">
                <h2>
                    <span style="color: #ff0000;">üì∫</span> YouTube Integration
                    <span id="youtubeStatus" class="status-badge status-disconnected">Not Connected</span>
                </h2>
                <p style="color: var(--text-dim); margin-bottom: 15px;">
                    Connect to YouTube to receive Super Chat commands from your live stream.
                </p>
                
                <div class="setup-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Create a Google Cloud Project</h4>
                        <p>Go to <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color: var(--info);">Google Cloud Console</a>, create a project, enable the YouTube Data API v3, and create OAuth credentials. Set the redirect URI to: <code id="youtubeRedirectUrl">Loading...</code></p>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Client ID</label>
                        <input type="text" id="youtubeClientId" placeholder="Your Google Client ID">
                    </div>
                    <div class="form-group">
                        <label>Client Secret</label>
                        <input type="password" id="youtubeClientSecret" placeholder="Your Google Client Secret">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Live Stream Video ID</label>
                        <input type="text" id="youtubeVideoId" placeholder="e.g., dQw4w9WgXcQ">
                        <small>The video ID from your live stream URL</small>
                    </div>
                    <div class="form-group">
                        <label>Minimum Super Chat ($)</label>
                        <input type="number" id="youtubeMinAmount" value="1.00" min="0" step="0.01">
                    </div>
                </div>
                
                <div class="form-group checkbox-group">
                    <input type="checkbox" id="youtubeAllowChat">
                    <label for="youtubeAllowChat" style="margin: 0;">Also allow regular chat commands (not just Super Chats)</label>
                </div>
                
                <div class="btn-group">
                    <button onclick="saveYouTubeCredentials()" class="btn-secondary">üíæ Save Credentials</button>
                    <button onclick="authorizeYouTube()" class="youtube-btn">üîó Login with YouTube</button>
                    <button onclick="startYouTube()" id="youtubeStartBtn" class="btn-info">‚ñ∂Ô∏è Start Listening</button>
                    <button onclick="stopYouTube()" id="youtubeStopBtn" class="btn-danger hidden">‚èπÔ∏è Stop</button>
                </div>
            </div>
            
            <!-- Test Client Mode -->
            <div class="card">
                <h2>
                    üß™ AI-Driven Test Client Mode
                    <span id="testClientStatus" class="status-badge status-disconnected">Disabled</span>
                </h2>
                <div class="alert alert-info" style="margin-bottom: 15px;">
                    <strong>‚ÑπÔ∏è About AI-Driven Test Client Mode:</strong> Run GMod with <code>-multirun</code> to have a separate test client receive and execute commands first. If the code fails, an <strong>AI agent</strong> will automatically analyze the error and fix the code, retrying up to 3 times. Only working code is sent to your main player client. This protects your main game from seeing crashes or errors!
                </div>
                
                <div class="form-group checkbox-group">
                    <input type="checkbox" id="testClientModeToggle" onchange="toggleTestClientMode()">
                    <label for="testClientModeToggle" style="margin: 0; font-weight: bold;">Enable AI-Driven Test Client Mode</label>
                </div>
                
                <div id="testClientSettings" class="hidden" style="margin-top: 15px;">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Test Map</label>
                            <input type="text" id="testClientMap" value="gm_flatgrass" placeholder="gm_flatgrass">
                            <small>Small/fast-loading map for test client</small>
                        </div>
                        <div class="form-group">
                            <label>Timeout (seconds)</label>
                            <input type="number" id="testClientTimeout" value="10" min="5" max="60">
                            <small>How long to wait for test results</small>
                        </div>
                    </div>
                    
                    <div class="form-group checkbox-group">
                        <input type="checkbox" id="testClientCleanup" checked>
                        <label for="testClientCleanup" style="margin: 0;">Run gmod_admin_cleanup after each test</label>
                    </div>
                    
                    <div class="form-group">
                        <label>GMod Executable Path (for auto-launch)</label>
                        <input type="text" id="testClientGmodPath" placeholder="C:\Program Files (x86)\Steam\steamapps\common\GarrysMod\gmod.exe">
                        <small>Optional: Path to gmod.exe for launching test client automatically</small>
                    </div>
                    
                    <div class="btn-group">
                        <button onclick="saveTestClientSettings()" class="btn-secondary">üíæ Save Settings</button>
                        <button onclick="launchTestClient()" id="testClientLaunchBtn" class="btn-info">üöÄ Launch Test Client</button>
                    </div>
                    
                    <div id="testClientInfo" class="hidden" style="margin-top: 15px;">
                        <div class="alert alert-success">
                            <strong>‚úÖ Test Client Connected!</strong>
                            <div style="margin-top: 5px; font-size: 12px;">
                                Last poll: <span id="testClientLastPoll">Never</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(0,255,0,0.1); border-radius: 5px;">
                            <strong>ü§ñ AI Error-Fixing Active</strong>
                            <p style="margin: 5px 0 0 0; font-size: 12px; color: var(--text-dim);">
                                When code fails on test client, AI will analyze the error and generate a fix (up to 3 attempts).
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isLoggedIn = false;
        let adminPassword = '';
        
        // Check admin status on load
        async function checkAdminStatus() {
            try {
                const response = await fetch('/api/setup/admin/status');
                const data = await response.json();
                
                if (!data.isConfigured) {
                    // No password set - show set password form
                    document.getElementById('loginForm').classList.add('hidden');
                    document.getElementById('setPasswordForm').classList.remove('hidden');
                } else {
                    // Password is set - show login form
                    document.getElementById('loginForm').classList.remove('hidden');
                    document.getElementById('setPasswordForm').classList.add('hidden');
                }
            } catch (err) {
                console.error('Failed to check admin status:', err);
            }
        }
        
        async function setPassword() {
            const newPass = document.getElementById('newPassword').value;
            const confirmPass = document.getElementById('confirmPassword').value;
            
            if (newPass.length < 4) {
                showLoginAlert('Password must be at least 4 characters', 'error');
                return;
            }
            
            if (newPass !== confirmPass) {
                showLoginAlert('Passwords do not match', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/setup/admin/password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ newPassword: newPass })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    adminPassword = newPass;
                    showSetupContent();
                } else {
                    showLoginAlert(data.message || 'Failed to set password', 'error');
                }
            } catch (err) {
                showLoginAlert('Network error', 'error');
            }
        }
        
        async function login() {
            const password = document.getElementById('loginPassword').value;
            
            try {
                const response = await fetch('/api/setup/admin/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    adminPassword = password;
                    showSetupContent();
                } else {
                    showLoginAlert(data.message || 'Invalid password', 'error');
                }
            } catch (err) {
                showLoginAlert('Network error', 'error');
            }
        }
        
        function showLoginAlert(message, type) {
            const container = document.getElementById('loginAlert');
            container.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
        }
        
        function showSetupContent() {
            isLoggedIn = true;
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('setupContent').classList.remove('hidden');
            loadSetupStatus();
            loadModels();
            loadOpenRouterSettings();
            loadPrivateDiscordMode();
            loadTestClientSettings();
        }
        
        async function loadPrivateDiscordMode() {
            try {
                const response = await fetch('/api/setup/private-discord-mode');
                const data = await response.json();
                
                const toggle = document.getElementById('privateDiscordModeToggle');
                const status = document.getElementById('privateDiscordModeStatus');
                
                toggle.checked = data.enabled;
                if (data.enabled) {
                    status.textContent = 'Enabled';
                    status.className = 'status-badge status-connected';
                } else {
                    status.textContent = 'Disabled';
                    status.className = 'status-badge status-disconnected';
                }
            } catch (err) {
                console.error('Failed to load Private Discord Mode setting:', err);
            }
        }
        
        async function togglePrivateDiscordMode() {
            const toggle = document.getElementById('privateDiscordModeToggle');
            const enabled = toggle.checked;
            
            try {
                const response = await fetch('/api/setup/private-discord-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    const status = document.getElementById('privateDiscordModeStatus');
                    if (data.enabled) {
                        status.textContent = 'Enabled';
                        status.className = 'status-badge status-connected';
                        showAlert('Private Discord Mode enabled - ALL safety filters disabled!', 'warning');
                    } else {
                        status.textContent = 'Disabled';
                        status.className = 'status-badge status-disconnected';
                        showAlert('Private Discord Mode disabled - safety filters active', 'success');
                    }
                } else {
                    toggle.checked = !enabled; // Revert on failure
                    showAlert(data.message || 'Failed to update setting', 'error');
                }
            } catch (err) {
                toggle.checked = !enabled; // Revert on failure
                showAlert('Network error', 'error');
            }
        }
        
        async function simulateSuperChat() {
            const userId = document.getElementById('superChatUserId').value.trim();
            const displayName = document.getElementById('superChatDisplayName').value.trim();
            const amount = parseFloat(document.getElementById('superChatAmount').value);
            const resultDiv = document.getElementById('superChatResult');
            
            if (!userId) {
                resultDiv.innerHTML = '<div class="alert alert-error">User ID is required</div>';
                return;
            }
            
            if (isNaN(amount) || amount <= 0) {
                resultDiv.innerHTML = '<div class="alert alert-error">Amount must be a positive number</div>';
                return;
            }
            
            try {
                const response = await fetch('/api/user/simulate-superchat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: userId,
                        displayName: displayName || 'Simulated User',
                        amount: amount
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    resultDiv.innerHTML = `<div class="alert alert-success">${data.message}. New balance: $${data.newBalance.toFixed(2)}</div>`;
                } else {
                    resultDiv.innerHTML = `<div class="alert alert-error">${data.message}</div>`;
                }
            } catch (err) {
                resultDiv.innerHTML = '<div class="alert alert-error">Network error</div>';
            }
        }
        
        async function simulateYouTubeApi() {
            const channelId = document.getElementById('ytApiChannelId').value.trim();
            const displayName = document.getElementById('ytApiDisplayName').value.trim();
            const message = document.getElementById('ytApiMessage').value.trim();
            const amount = parseFloat(document.getElementById('ytApiAmount').value);
            const resultDiv = document.getElementById('ytApiResult');
            
            if (!channelId) {
                resultDiv.innerHTML = '<div class="alert alert-error">YouTube Channel ID is required</div>';
                return;
            }
            
            if (isNaN(amount) || amount <= 0) {
                resultDiv.innerHTML = '<div class="alert alert-error">Amount must be a positive number</div>';
                return;
            }
            
            try {
                const response = await fetch('/api/user/simulate-youtube-api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channelId: channelId,
                        displayName: displayName || 'Test User',
                        message: message || undefined,
                        amount: amount
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    resultDiv.innerHTML = `<div class="alert alert-success">${data.message}</div>`;
                } else {
                    resultDiv.innerHTML = `<div class="alert alert-error">${data.message}</div>`;
                }
            } catch (err) {
                resultDiv.innerHTML = '<div class="alert alert-error">Network error</div>';
            }
        }
        
        async function loadOpenRouterSettings() {
            try {
                const response = await fetch('/api/setup/openrouter');
                const data = await response.json();
                
                if (data.apiKey) {
                    document.getElementById('openrouterApiKey').value = data.apiKey;
                }
            } catch (err) {
                console.error('Failed to load OpenRouter settings:', err);
            }
        }
        
        async function changePassword() {
            const currentPass = document.getElementById('currentPassword').value;
            const newPass = document.getElementById('changePassword').value;
            
            if (newPass.length < 4) {
                showAlert('Password must be at least 4 characters', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/setup/admin/password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ currentPassword: currentPass, newPassword: newPass })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    adminPassword = newPass;
                    showAlert('Password changed successfully', 'success');
                    document.getElementById('currentPassword').value = '';
                    document.getElementById('changePassword').value = '';
                } else {
                    showAlert(data.message || 'Failed to change password', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        function showAlert(message, type) {
            const container = document.getElementById('alerts');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            container.prepend(alert);
            setTimeout(() => alert.remove(), 5000);
        }
        
        async function loadSetupStatus() {
            try {
                const response = await fetch('/api/setup/status');
                const data = await response.json();
                updateSetupUI(data);
            } catch (err) {
                console.error('Failed to load setup status:', err);
            }
            
            // Update redirect URLs
            const baseUrl = window.location.origin;
            document.getElementById('twitchRedirectUrl').textContent = `${baseUrl}/api/setup/twitch/callback`;
            document.getElementById('youtubeRedirectUrl').textContent = `${baseUrl}/api/setup/youtube/callback`;
        }
        
        async function loadModels() {
            try {
                const response = await fetch('/api/setup/models');
                const data = await response.json();
                
                const select = document.getElementById('openrouterModel');
                select.innerHTML = data.models.map(m => 
                    `<option value="${m.id}" ${m.id === data.currentModel ? 'selected' : ''}>${m.name} (${m.provider})</option>`
                ).join('');
            } catch (err) {
                console.error('Failed to load models:', err);
            }
        }
        
        function updateSetupUI(data) {
            // OpenRouter
            const orStatus = document.getElementById('openrouterStatus');
            if (data.openRouterConfigured) {
                orStatus.textContent = 'Configured';
                orStatus.className = 'status-badge status-connected';
            } else {
                orStatus.textContent = 'Not Configured';
                orStatus.className = 'status-badge status-disconnected';
            }
            
            // Tunnel
            const tunnelStatus = document.getElementById('tunnelStatus');
            const tunnelUrl = document.getElementById('tunnelUrl');
            const publicIpInfo = document.getElementById('publicIpInfo');
            const boreStartBtn = document.getElementById('boreStartBtn');
            const ngrokStartBtn = document.getElementById('ngrokStartBtn');
            const ltStartBtn = document.getElementById('ltStartBtn');
            const tunnelStopBtn = document.getElementById('tunnelStopBtn');
            
            if (data.tunnel && data.tunnel.isRunning) {
                tunnelStatus.textContent = `${data.tunnel.type} Running`;
                tunnelStatus.className = 'status-badge status-connected';
                tunnelUrl.classList.remove('hidden');
                document.getElementById('tunnelUrlLink').href = data.tunnel.url;
                document.getElementById('tunnelUrlLink').textContent = data.tunnel.url;
                document.getElementById('pollUrl').textContent = data.tunnel.url + '/poll';
                boreStartBtn.classList.add('hidden');
                ngrokStartBtn.classList.add('hidden');
                ltStartBtn.classList.add('hidden');
                tunnelStopBtn.classList.remove('hidden');
                
                if (data.tunnel.type === 'LocalTunnel' && data.tunnel.publicIp) {
                    publicIpInfo.classList.remove('hidden');
                    document.getElementById('publicIp').textContent = data.tunnel.publicIp;
                } else {
                    publicIpInfo.classList.add('hidden');
                }
            } else {
                tunnelStatus.textContent = 'Not Running';
                tunnelStatus.className = 'status-badge status-disconnected';
                tunnelUrl.classList.add('hidden');
                publicIpInfo.classList.add('hidden');
                boreStartBtn.classList.remove('hidden');
                ngrokStartBtn.classList.remove('hidden');
                ltStartBtn.classList.remove('hidden');
                tunnelStopBtn.classList.add('hidden');
            }
            
            // Twitch
            const twitchStatus = document.getElementById('twitchStatus');
            const twitchConnectBtn = document.getElementById('twitchConnectBtn');
            const twitchDisconnectBtn = document.getElementById('twitchDisconnectBtn');
            
            if (data.twitch.isListening) {
                twitchStatus.textContent = `Listening: ${data.twitch.channel}`;
                twitchStatus.className = 'status-badge status-connected';
                twitchConnectBtn.classList.add('hidden');
                twitchDisconnectBtn.classList.remove('hidden');
            } else if (data.twitch.isAuthenticated) {
                twitchStatus.textContent = 'Authenticated';
                twitchStatus.className = 'status-badge status-pending';
                twitchConnectBtn.classList.remove('hidden');
                twitchDisconnectBtn.classList.add('hidden');
            } else {
                twitchStatus.textContent = 'Not Connected';
                twitchStatus.className = 'status-badge status-disconnected';
                twitchConnectBtn.classList.remove('hidden');
                twitchDisconnectBtn.classList.add('hidden');
            }
            
            // YouTube
            const youtubeStatus = document.getElementById('youtubeStatus');
            const youtubeStartBtn = document.getElementById('youtubeStartBtn');
            const youtubeStopBtn = document.getElementById('youtubeStopBtn');
            
            if (data.youTube.isListening) {
                youtubeStatus.textContent = `Listening: ${data.youTube.videoId}`;
                youtubeStatus.className = 'status-badge status-connected';
                youtubeStartBtn.classList.add('hidden');
                youtubeStopBtn.classList.remove('hidden');
            } else if (data.youTube.isAuthenticated) {
                youtubeStatus.textContent = 'Authenticated';
                youtubeStatus.className = 'status-badge status-pending';
                youtubeStartBtn.classList.remove('hidden');
                youtubeStopBtn.classList.add('hidden');
            } else {
                youtubeStatus.textContent = 'Not Connected';
                youtubeStatus.className = 'status-badge status-disconnected';
                youtubeStartBtn.classList.remove('hidden');
                youtubeStopBtn.classList.add('hidden');
            }
            
            // Test Client
            if (data.testClient) {
                const testClientStatus = document.getElementById('testClientStatus');
                const testClientToggle = document.getElementById('testClientModeToggle');
                const testClientSettings = document.getElementById('testClientSettings');
                const testClientInfo = document.getElementById('testClientInfo');
                
                testClientToggle.checked = data.testClient.enabled;
                
                if (data.testClient.enabled) {
                    testClientSettings.classList.remove('hidden');
                    if (data.testClient.isConnected) {
                        testClientStatus.textContent = 'Connected';
                        testClientStatus.className = 'status-badge status-connected';
                        testClientInfo.classList.remove('hidden');
                        if (data.testClient.lastPollTime) {
                            document.getElementById('testClientLastPoll').textContent = new Date(data.testClient.lastPollTime).toLocaleTimeString();
                        }
                    } else {
                        testClientStatus.textContent = 'Enabled (Waiting)';
                        testClientStatus.className = 'status-badge status-pending';
                        testClientInfo.classList.add('hidden');
                    }
                } else {
                    testClientStatus.textContent = 'Disabled';
                    testClientStatus.className = 'status-badge status-disconnected';
                    testClientSettings.classList.add('hidden');
                    testClientInfo.classList.add('hidden');
                }
            }
        }
        
        // Tunnel functions
        async function startBore() {
            const errorDiv = document.getElementById('tunnelError');
            errorDiv.classList.add('hidden');
            
            try {
                showAlert('Starting Bore...', 'info');
                const response = await fetch('/api/setup/tunnel/bore/start', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`Bore started: ${data.url}`, 'success');
                    loadSetupStatus();
                } else {
                    const errorMsg = data.message || 'Failed to start Bore';
                    errorDiv.innerHTML = `<strong>‚ùå Error:</strong> ${errorMsg}<br><br>
                        <strong>To install Bore:</strong><br>
                        1. Install Rust from <a href="https://rustup.rs" target="_blank" style="color: var(--info);">rustup.rs</a><br>
                        2. Run: <code style="background: #333; padding: 2px 6px; border-radius: 3px;">cargo install bore-cli</code><br>
                        <em>Or download binary from <a href="https://github.com/ekzhang/bore/releases" target="_blank" style="color: var(--info);">GitHub Releases</a></em>`;
                    errorDiv.classList.remove('hidden');
                    showAlert(errorMsg, 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function startNgrok() {
            const errorDiv = document.getElementById('tunnelError');
            errorDiv.classList.add('hidden');
            
            try {
                showAlert('Starting ngrok...', 'info');
                const response = await fetch('/api/setup/tunnel/ngrok/start', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`ngrok started: ${data.url}`, 'success');
                    loadSetupStatus();
                } else {
                    const errorMsg = data.message || 'Failed to start ngrok';
                    errorDiv.innerHTML = `<strong>‚ùå Error:</strong> ${errorMsg}<br><br>
                        <strong>To install ngrok:</strong><br>
                        1. Download from <a href="https://ngrok.com/download" target="_blank" style="color: var(--info);">ngrok.com/download</a><br>
                        2. Extract and add to your PATH<br>
                        3. Sign up for free and run: <code>ngrok config add-authtoken YOUR_TOKEN</code>`;
                    errorDiv.classList.remove('hidden');
                    showAlert(errorMsg, 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function startLocalTunnel() {
            const errorDiv = document.getElementById('tunnelError');
            errorDiv.classList.add('hidden');
            
            try {
                showAlert('Starting LocalTunnel...', 'info');
                const response = await fetch('/api/setup/tunnel/localtunnel/start', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`LocalTunnel started: ${data.url}`, 'success');
                    loadSetupStatus();
                } else {
                    const errorMsg = data.message || 'Failed to start LocalTunnel';
                    errorDiv.innerHTML = `<strong>‚ùå Error:</strong> ${errorMsg}<br><br>
                        <strong>To install LocalTunnel:</strong><br>
                        1. Install Node.js from <a href="https://nodejs.org" target="_blank" style="color: var(--info);">nodejs.org</a><br>
                        2. Run: <code style="background: #333; padding: 2px 6px; border-radius: 3px;">npm install -g localtunnel</code>`;
                    errorDiv.classList.remove('hidden');
                    showAlert(errorMsg, 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function stopTunnel() {
            try {
                await fetch('/api/setup/tunnel/stop', { method: 'POST' });
                showAlert('Tunnel stopped', 'info');
                loadSetupStatus();
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        // OpenRouter
        async function saveOpenRouter() {
            const apiKey = document.getElementById('openrouterApiKey').value;
            const model = document.getElementById('openrouterModel').value;
            
            try {
                const response = await fetch('/api/setup/openrouter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apiKey, model })
                });
                
                if (response.ok) {
                    showAlert('OpenRouter settings saved!', 'success');
                    loadSetupStatus();
                } else {
                    showAlert('Failed to save settings', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        // Twitch
        async function saveTwitchCredentials() {
            const data = {
                clientId: document.getElementById('twitchClientId').value,
                clientSecret: document.getElementById('twitchClientSecret').value,
                channel: document.getElementById('twitchChannel').value,
                chatCommand: document.getElementById('twitchCommand').value,
                requireBits: document.getElementById('twitchRequireBits').checked,
                minBitsAmount: parseInt(document.getElementById('twitchMinBits').value) || 100
            };
            
            try {
                const response = await fetch('/api/setup/twitch/credentials', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    showAlert('Twitch credentials saved!', 'success');
                } else {
                    showAlert('Failed to save Twitch credentials', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function authorizeTwitch() {
            try {
                const response = await fetch('/api/setup/twitch/auth-url');
                const data = await response.json();
                
                if (data.authUrl) {
                    window.location.href = data.authUrl;
                } else {
                    showAlert(data.message || 'Failed to get auth URL', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function connectTwitch() {
            try {
                const response = await fetch('/api/setup/twitch/connect', { method: 'POST' });
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`Connected to Twitch: ${data.channel}`, 'success');
                    loadSetupStatus();
                } else {
                    showAlert(data.message || 'Failed to connect', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function disconnectTwitch() {
            try {
                await fetch('/api/setup/twitch/disconnect', { method: 'POST' });
                showAlert('Disconnected from Twitch', 'info');
                loadSetupStatus();
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        // YouTube
        async function saveYouTubeCredentials() {
            const data = {
                clientId: document.getElementById('youtubeClientId').value,
                clientSecret: document.getElementById('youtubeClientSecret').value,
                videoId: document.getElementById('youtubeVideoId').value,
                minSuperChatAmount: parseFloat(document.getElementById('youtubeMinAmount').value) || 1.00,
                allowRegularChat: document.getElementById('youtubeAllowChat').checked
            };
            
            try {
                const response = await fetch('/api/setup/youtube/credentials', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    showAlert('YouTube credentials saved!', 'success');
                } else {
                    showAlert('Failed to save YouTube credentials', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function authorizeYouTube() {
            try {
                const response = await fetch('/api/setup/youtube/auth-url');
                const data = await response.json();
                
                if (data.authUrl) {
                    window.location.href = data.authUrl;
                } else {
                    showAlert(data.message || 'Failed to get auth URL', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function startYouTube() {
            const videoId = document.getElementById('youtubeVideoId').value;
            
            try {
                const response = await fetch('/api/setup/youtube/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ videoId })
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`Started listening to YouTube: ${data.videoId}`, 'success');
                    loadSetupStatus();
                } else {
                    showAlert(data.message || 'Failed to start', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function stopYouTube() {
            try {
                await fetch('/api/setup/youtube/stop', { method: 'POST' });
                showAlert('Stopped YouTube listener', 'info');
                loadSetupStatus();
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        // Test Client functions
        async function loadTestClientSettings() {
            try {
                const response = await fetch('/api/setup/test-client');
                const data = await response.json();
                
                document.getElementById('testClientModeToggle').checked = data.enabled;
                document.getElementById('testClientMap').value = data.testMap || 'gm_flatgrass';
                document.getElementById('testClientTimeout').value = data.timeoutSeconds || 10;
                document.getElementById('testClientCleanup').checked = data.cleanupAfterTest !== false;
                document.getElementById('testClientGmodPath').value = data.gmodPath || '';
                
                if (data.enabled) {
                    document.getElementById('testClientSettings').classList.remove('hidden');
                }
            } catch (err) {
                console.error('Failed to load test client settings:', err);
            }
        }
        
        async function toggleTestClientMode() {
            const toggle = document.getElementById('testClientModeToggle');
            const enabled = toggle.checked;
            
            try {
                const response = await fetch('/api/setup/test-client/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    const status = document.getElementById('testClientStatus');
                    const settings = document.getElementById('testClientSettings');
                    
                    if (data.enabled) {
                        status.textContent = 'Enabled (Waiting)';
                        status.className = 'status-badge status-pending';
                        settings.classList.remove('hidden');
                        showAlert('Test Client Mode enabled! Launch a GMod test client to begin.', 'success');
                    } else {
                        status.textContent = 'Disabled';
                        status.className = 'status-badge status-disconnected';
                        settings.classList.add('hidden');
                        showAlert('Test Client Mode disabled', 'info');
                    }
                } else {
                    toggle.checked = !enabled;
                    showAlert(data.message || 'Failed to toggle test client mode', 'error');
                }
            } catch (err) {
                toggle.checked = !enabled;
                showAlert('Network error', 'error');
            }
        }
        
        async function saveTestClientSettings() {
            const settings = {
                testMap: document.getElementById('testClientMap').value,
                timeoutSeconds: parseInt(document.getElementById('testClientTimeout').value) || 10,
                cleanupAfterTest: document.getElementById('testClientCleanup').checked,
                gmodPath: document.getElementById('testClientGmodPath').value
            };
            
            try {
                const response = await fetch('/api/setup/test-client/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert('Test client settings saved!', 'success');
                } else {
                    showAlert(data.message || 'Failed to save settings', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        async function launchTestClient() {
            try {
                showAlert('Launching test client...', 'info');
                const response = await fetch('/api/setup/test-client/launch', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(data.message + (data.note ? ` ${data.note}` : ''), 'success');
                } else {
                    showAlert(data.message || 'Failed to launch test client', 'error');
                }
            } catch (err) {
                showAlert('Network error', 'error');
            }
        }
        
        // Check URL for success/error messages
        const params = new URLSearchParams(window.location.search);
        if (params.get('success')) {
            // Wait for login then show message
            setTimeout(() => {
                if (isLoggedIn) {
                    showAlert(`${params.get('success')} connected successfully!`, 'success');
                }
            }, 500);
        }
        if (params.get('error')) {
            setTimeout(() => {
                if (isLoggedIn) {
                    showAlert(`Authentication failed: ${params.get('error')}`, 'error');
                }
            }, 500);
        }
        
        // Initialize
        checkAdminStatus();
    </script>
</body>
</html>
